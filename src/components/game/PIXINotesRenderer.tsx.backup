/**
 * Phase 3: PIXI.js ãƒãƒ¼ãƒ„ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚·ã‚¹ãƒ†ãƒ 
 * é«˜æ€§èƒ½ãªãƒãƒ¼ãƒ„é™ä¸‹ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ - ParticleContainer + ãƒ†ã‚¯ã‚¹ãƒãƒ£æœ€é©åŒ–ç‰ˆ
 */

import React, { useEffect, useRef } from 'react';
import * as PIXI from 'pixi.js';
import type { ActiveNote } from '@/types';
import { unifiedFrameController, renderOptimizer, performanceMonitor } from '@/utils/performanceOptimizer';

// ===== å‹å®šç¾© =====

interface PIXINotesRendererProps {
  activeNotes: ActiveNote[];
  width: number;
  height: number;
  currentTime: number; // ç¾åœ¨æ™‚åˆ»ã‚’è¿½åŠ ï¼ˆã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŒæœŸç”¨ï¼‰
  /** ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼æº–å‚™å®Œäº†ãƒ»ç ´æ£„é€šçŸ¥ã€‚null ã§ç ´æ£„ã‚’ç¤ºã™ */
  onReady?: (renderer: PIXINotesRendererInstance | null) => void;
  className?: string;
}

interface NoteSprite {
  sprite: PIXI.Sprite; // Graphics ã‹ã‚‰ Sprite ã«å¤‰æ›´
  noteData: ActiveNote;
  glowSprite?: PIXI.Graphics;
  label?: PIXI.Sprite; // Text ã‹ã‚‰ Sprite ã«å¤‰æ›´ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ç”¨ï¼‰
}

interface RendererSettings {
  noteWidth: number;
  noteHeight: number;
  hitLineY: number;
  pianoHeight: number;
  noteSpeed: number;
  colors: {
    visible: number;
    visibleBlack: number;
    hit: number;
    missed: number;
    perfect: number;
    good: number;
    whiteKey: number;
    blackKey: number;
    activeKey: number;
  };
  effects: {
    glow: boolean;
    particles: boolean;
    trails: boolean;
  };
  /** çµ±ä¸€ã•ã‚ŒãŸéŸ³åè¡¨ç¤ºãƒ¢ãƒ¼ãƒ‰ï¼ˆéµç›¤ãƒ»ãƒãƒ¼ãƒ„å…±é€šï¼‰*/
  noteNameStyle: 'off' | 'abc' | 'solfege';
  noteAccidentalStyle: 'sharp' | 'flat';
  /** ã‚¹ãƒˆã‚¢ã® transpose å€¤ï¼ˆÂ±6ï¼‰ */
  transpose: number;
  /** ç·´ç¿’ãƒ¢ãƒ¼ãƒ‰ã‚¬ã‚¤ãƒ‰è¨­å®š */
  practiceGuide?: 'off' | 'key' | 'key_auto';
}

// ===== ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚­ãƒ£ãƒƒã‚·ãƒ¥ =====
interface NoteTextures {
  whiteVisible: PIXI.Texture;
  blackVisible: PIXI.Texture;
  hit: PIXI.Texture;
  missed: PIXI.Texture;
}

interface LabelTextures {
  abc_sharp: Map<string, PIXI.Texture>;
  abc_flat: Map<string, PIXI.Texture>;
  solfege_sharp: Map<string, PIXI.Texture>;
  solfege_flat: Map<string, PIXI.Texture>;
}

// ===== PIXI.js ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼ã‚¯ãƒ©ã‚¹ =====

export class PIXINotesRendererInstance {
  private app: PIXI.Application;
  private container!: PIXI.Container;
  private notesContainer!: PIXI.ParticleContainer; // ParticleContainer ã«å¤‰æ›´
  private labelsContainer!: PIXI.ParticleContainer; // ãƒ©ãƒ™ãƒ«å°‚ç”¨ã‚³ãƒ³ãƒ†ãƒŠï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–ï¼‰
  private effectsContainer!: PIXI.Container;
  private hitLineContainer!: PIXI.Container;
  private pianoContainer!: PIXI.Container;
  
  private noteSprites: Map<string, NoteSprite> = new Map();
  private particles!: PIXI.Container;
  private pianoSprites: Map<number, PIXI.Graphics> = new Map();
  private highlightedKeys: Set<number> = new Set(); // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã®ã‚­ãƒ¼ã‚’è¿½è·¡
  
  // ===== ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚­ãƒ£ãƒƒã‚·ãƒ¥ =====
  private noteTextures!: NoteTextures;
  private labelTextures!: LabelTextures;
  
  // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰å…¥åŠ›ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯
  private onKeyPress?: (note: number) => void;
  private onKeyRelease?: (note: number) => void;
  
  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
  private fpsCounter = 0;
  private lastFpsTime = 0;
  
  // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯åˆ¶å¾¡
  private labelContainerFallback = false;
  
  // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ç”¨
  /* eslint-disable @typescript-eslint/no-unused-vars */
  private _currentTime: number = 0;
  private _animationSpeed: number = 1.0;
  /* eslint-enable */
  private lastFrameTime: number = performance.now();
  
  private settings: RendererSettings = {
    noteWidth: 5,
    noteHeight: 5,
    hitLineY: 0,
    pianoHeight: 160,
    noteSpeed: 1.0,
    colors: {
      visible: 0x3B82F6,       // blue-500ï¼ˆç™½éµãƒãƒ¼ãƒ„ï¼‰
      visibleBlack: 0x8B5CF6,  // violet-500ï¼ˆé»’éµãƒãƒ¼ãƒ„ï¼‰
      hit: 0x10B981,           // emerald-500
      missed: 0xEF4444,        // red-500
      perfect: 0xF59E0B,       // amber-500
      good: 0x8B5CF6,          // violet-500
      whiteKey: 0xFFFFFF,      // white
      blackKey: 0x000000,      // pure black
      activeKey: 0xFBBF24,     // amber-400
    },
    effects: {
      glow: false,             // ã‚°ãƒ­ãƒ¼åŠ¹æœã‚’å®Œå…¨ç„¡åŠ¹åŒ–
      particles: false,        // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«åŠ¹æœã‚’å®Œå…¨ç„¡åŠ¹åŒ–
      trails: false            // ãƒˆãƒ¬ã‚¤ãƒ«åŠ¹æœã‚’å®Œå…¨ç„¡åŠ¹åŒ–
    },
    noteNameStyle: 'abc',
    noteAccidentalStyle: 'sharp',
    transpose: 0,
    practiceGuide: 'key'
  };
  
  private onDragActive: boolean = false;
  private currentDragNote: number | null = null;
  
  constructor(width: number, height: number) {
    console.log(`ğŸ¯ PIXINotesRenderer constructor: ${width}x${height}`);
    
    // PIXI.js ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–ï¼ˆunifiedFrameControllerçµ±åˆç‰ˆï¼‰
    this.app = new PIXI.Application({
      width,
      height,
      backgroundColor: 0x0A0A0F, // ã‚ˆã‚Šæš—ã„å®‡å®™çš„ãªèƒŒæ™¯
      antialias: true,
      resolution: 1, // è§£åƒåº¦ã‚’å›ºå®šã—ã¦ä¸€è²«æ€§ã‚’ä¿ã¤
      autoDensity: false, // è‡ªå‹•å¯†åº¦èª¿æ•´ã‚’ç„¡åŠ¹åŒ–
      resizeTo: undefined, // è‡ªå‹•ãƒªã‚µã‚¤ã‚ºã‚’ç„¡åŠ¹åŒ–
      powerPreference: 'high-performance', // é«˜æ€§èƒ½GPUä½¿ç”¨
      backgroundAlpha: 1,
      clearBeforeRender: true,
      preserveDrawingBuffer: false // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹å‘ä¸Š
    });
    
    // å¼·åˆ¶çš„ã«Canvasã‚µã‚¤ã‚ºã‚’è¨­å®š
    this.app.renderer.resize(width, height);
    
    console.log(`ğŸ¯ PIXI.js App created - Canvas: ${this.app.view.width}x${this.app.view.height}`);
    console.log(`ğŸ¯ PIXI.js App view element:`, this.app.view);
    
    // ===== ç«¶åˆãƒ«ãƒ¼ãƒ—è§£æ±ºï¼šPIXIã‚’ unifiedFrameController é…ä¸‹ã«çµ±åˆ =====
    // PIXIã®è‡ªå‹•ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆåˆ¶å¾¡ã‚’ç„¡åŠ¹åŒ–ï¼ˆunifiedFrameControllerãŒç®¡ç†ï¼‰
    this.app.ticker.autoStart = false;
    this.app.ticker.stop();
    
    // ç·Šæ€¥å¯¾ç­–: æ‰‹å‹•ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°æœ‰åŠ¹åŒ–ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    console.log('âš ï¸ Enabling manual rendering for debugging...');
    this.app.ticker.start();
    console.log('âœ… PIXI ticker started manually');
    
    // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹åŒ–ï¼ˆé‡è¦ï¼‰
    this.app.stage.eventMode = 'static';
    
    // åˆ¤å®šãƒ©ã‚¤ãƒ³ã‚’ãƒ”ã‚¢ãƒã®ä¸Šç«¯ã«æ­£ç¢ºã«é…ç½®
    // ç·Šæ€¥ä¿®æ­£: å®Ÿéš›ã®Canvasé«˜ã•ã«åŸºã¥ã„ã¦è¨ˆç®—
    const actualHeight = this.app.view.height;
    this.settings.hitLineY = actualHeight - this.settings.pianoHeight;
    
    console.log(`ğŸš¨ Size mismatch detected!`);
    console.log(`ğŸš¨ Constructor size: ${width}x${height}`);
    console.log(`ğŸš¨ Actual canvas size: ${this.app.view.width}x${this.app.view.height}`);
    console.log(`ğŸš¨ Original hitLineY: ${height - this.settings.pianoHeight}`);
    console.log(`ğŸš¨ Corrected hitLineY: ${this.settings.hitLineY}`);
    
    // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’äº‹å‰ç”Ÿæˆ
    console.log('ğŸ”§ Starting texture generation...');
    try {
      this.generateNoteTextures();
      console.log('âœ… generateNoteTextures completed');
    } catch (error) {
      console.error('âŒ generateNoteTextures failed:', error);
    }
    
    try {
      // å†æœ‰åŠ¹åŒ–
      this.generateLabelTextures();
      console.log('âœ… generateLabelTextures completed');
    } catch (error) {
      console.error('âŒ generateLabelTextures failed:', error);
    }
    
    // app.stage ã®åŸºæœ¬ãƒ†ã‚¹ãƒˆ
    console.log('ğŸ”§ Testing app.stage...');
    console.log('ğŸ”§ app.stage exists:', !!this.app.stage);
    console.log('ğŸ”§ app.stage children count:', this.app.stage.children.length);
    
    console.log('ğŸ”§ Starting setup sequence...');
    
    try {
      this.setupContainers();
      console.log('âœ… setupContainers completed');
    } catch (error) {
      console.error('âŒ setupContainers failed:', error);
    }
    
    try {
      this.createTestVisual(); // ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ†ã‚¹ãƒˆå›³å½¢ï¼ˆå†æœ‰åŠ¹åŒ–ï¼‰
      console.log('âœ… createTestVisual completed');
    } catch (error) {
      console.error('âŒ createTestVisual failed:', error);
    }
    
    try {
      this.createNotesAreaBackground(); // æ–°ã—ã„èƒŒæ™¯ã‚·ã‚¹ãƒ†ãƒ 
      console.log('âœ… createNotesAreaBackground completed');
    } catch (error) {
      console.error('âŒ createNotesAreaBackground failed:', error);
    }
    
    try {
      this.setupPiano();
      console.log('âœ… setupPiano completed');
    } catch (error) {
      console.error('âŒ setupPiano failed:', error);
    }
    
    try {
      this.setupHitLine();
      console.log('âœ… setupHitLine completed');
    } catch (error) {
      console.error('âŒ setupHitLine failed:', error);
    }
    
    try {
      this.setupParticles();
      console.log('âœ… setupParticles completed');
    } catch (error) {
      console.error('âŒ setupParticles failed:', error);
    }
    this.setupLightweightEffectsTicker(); // è»½é‡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚£ãƒƒã‚«ãƒ¼
    
    // ===== ç·Šæ€¥è¨ºæ–­: ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å¼·åˆ¶å®Ÿè¡Œ =====
    console.log('ğŸ”§ Manual rendering test...');
    
    // Stageå†…å®¹ç¢ºèª
    console.log('ğŸ”§ Final stage children count:', this.app.stage.children.length);
    
    // æ‰‹å‹•ãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°å®Ÿè¡Œ
    try {
      this.app.renderer.render(this.app.stage);
      console.log('âœ… Manual render successful');
    } catch (error) {
      console.error('âŒ Manual render failed:', error);
    }
    
    // å®šæœŸãƒ¬ãƒ³ãƒ€ãƒªãƒ³ã‚°ã‚‚é–‹å§‹
    const renderInterval = setInterval(() => {
      try {
        this.app.renderer.render(this.app.stage);
        console.log('ğŸ”„ Periodic render executed');
      } catch (error) {
        console.error('âŒ Periodic render failed:', error);
        clearInterval(renderInterval);
      }
    }, 100); // 100msé–“éš”
    
    // 5ç§’å¾Œã«åœæ­¢
    setTimeout(() => {
      clearInterval(renderInterval);
      console.log('ğŸ”§ Periodic rendering stopped');
    }, 5000);
  }

  /**
   * ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ†ã‚¹ãƒˆå›³å½¢ï¼ˆPIXI.jsè¡¨ç¤ºç¢ºèªï¼‰
   */
  private createTestVisual(): void {
    console.log('ğŸ§ª Creating test visual to verify PIXI.js canvas...');
    
    try {
      // èµ¤ã„çŸ©å½¢ã‚’ãƒ†ã‚¹ãƒˆæç”»
      const testRect = new PIXI.Graphics();
      testRect.beginFill(0xFF0000); // èµ¤è‰²
      testRect.drawRect(0, 0, 100, 50);
      testRect.endFill();
      testRect.x = 50;
      testRect.y = 50;
      
      this.container.addChild(testRect);
      console.log('âœ… Test rectangle added to main container');
      
      // é’ã„å††ã‚‚ãƒ†ã‚¹ãƒˆæç”»
      const testCircle = new PIXI.Graphics();
      testCircle.beginFill(0x0000FF); // é’è‰²
      testCircle.drawCircle(0, 0, 25);
      testCircle.endFill();
      testCircle.x = 200;
      testCircle.y = 100;
      
      this.container.addChild(testCircle);
      console.log('âœ… Test circle added to main container');
      
    } catch (error) {
      console.error('âŒ Failed to create test visual:', error);
    }
  }
  
  /**
   * ãƒãƒ¼ãƒ„ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’äº‹å‰ç”Ÿæˆ
   */
  private generateNoteTextures(): void {
    let { noteWidth, noteHeight } = this.settings;
    
    // æœ€å°ã‚µã‚¤ã‚ºã‚’ä¿è¨¼ï¼ˆè¡¨ç¤ºå•é¡Œã®ç·Šæ€¥å¯¾ç­–ï¼‰
    if (noteHeight < 20) {
      console.warn(`âš ï¸ Note height too small (${noteHeight}), using minimum 20px`);
      noteHeight = 20;
    }
    if (noteWidth < 10) {
      console.warn(`âš ï¸ Note width too small (${noteWidth}), using minimum 15px`);
      noteWidth = 15;
    }
    
    console.log(`ğŸ¯ Generating note textures with size: ${noteWidth}x${noteHeight}`);
    
    // ç™½éµãƒãƒ¼ãƒ„ãƒ†ã‚¯ã‚¹ãƒãƒ£
    const whiteGraphics = new PIXI.Graphics();
    this.drawNoteShapeToGraphics(whiteGraphics, 'visible', false, noteWidth, noteHeight);
    this.noteTextures = {
      whiteVisible: this.app.renderer.generateTexture(whiteGraphics),
      blackVisible: PIXI.Texture.EMPTY,
      hit: PIXI.Texture.EMPTY,
      missed: PIXI.Texture.EMPTY
    };
    
    // é»’éµãƒãƒ¼ãƒ„ãƒ†ã‚¯ã‚¹ãƒãƒ£
    const blackGraphics = new PIXI.Graphics();
    this.drawNoteShapeToGraphics(blackGraphics, 'visible', true, noteWidth, noteHeight);
    this.noteTextures.blackVisible = this.app.renderer.generateTexture(blackGraphics);
    
    // ãƒ’ãƒƒãƒˆçŠ¶æ…‹ãƒ†ã‚¯ã‚¹ãƒãƒ£ï¼ˆé€æ˜ï¼‰
    const hitGraphics = new PIXI.Graphics();
    this.drawNoteShapeToGraphics(hitGraphics, 'hit', false, noteWidth, noteHeight);
    this.noteTextures.hit = this.app.renderer.generateTexture(hitGraphics);
    
    // ãƒŸã‚¹çŠ¶æ…‹ãƒ†ã‚¯ã‚¹ãƒãƒ£
    const missedGraphics = new PIXI.Graphics();
    this.drawNoteShapeToGraphics(missedGraphics, 'missed', false, noteWidth, noteHeight);
    this.noteTextures.missed = this.app.renderer.generateTexture(missedGraphics);
    
    // Graphics ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
    whiteGraphics.destroy();
    blackGraphics.destroy();
    hitGraphics.destroy();
    missedGraphics.destroy();
  }

  /**
   * ãƒ©ãƒ™ãƒ«ç”¨ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ã‚’ç”Ÿæˆ
   */
  private generateLabelTextures(): void {
    console.log('ğŸ¯ Starting label texture generation...');
    
    try {
      // å…¨ã¦ã®éŸ³åãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’å®šç¾©
      const sharpNamesABC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      const flatNamesABC = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];
      const sharpNamesSolfege = ['ãƒ‰', 'ãƒ‰#', 'ãƒ¬', 'ãƒ¬#', 'ãƒŸ', 'ãƒ•ã‚¡', 'ãƒ•ã‚¡#', 'ã‚½', 'ã‚½#', 'ãƒ©', 'ãƒ©#', 'ã‚·'];
      const flatNamesSolfege = ['ãƒ‰', 'ãƒ¬â™­', 'ãƒ¬', 'ãƒŸâ™­', 'ãƒŸ', 'ãƒ•ã‚¡', 'ã‚½â™­', 'ã‚½', 'ãƒ©â™­', 'ãƒ©', 'ã‚·â™­', 'ã‚·'];

      // ãƒ©ãƒ™ãƒ«ã‚¹ã‚¿ã‚¤ãƒ«è¨­å®š
      const labelStyle = new PIXI.TextStyle({
        fontSize: 10,
        fill: 0xFFFFFF,
        fontFamily: 'Arial, sans-serif',
        fontWeight: 'bold',
        align: 'center',
        stroke: 0x000000,
        strokeThickness: 2
      });

      this.labelTextures = {
        abc_sharp: new Map(),
        abc_flat: new Map(), 
        solfege_sharp: new Map(),
        solfege_flat: new Map()
      };

      // ABC Sharp ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
      sharpNamesABC.forEach(name => {
        try {
          const text = new PIXI.Text(name, labelStyle);
          const texture = this.app.renderer.generateTexture(text);
          
          if (!texture || texture === PIXI.Texture.EMPTY) {
            console.warn(`âš ï¸ Failed to generate texture for ABC sharp: ${name}`);
            return;
          }
          
          this.labelTextures.abc_sharp.set(name, texture);
          text.destroy();
          console.log(`âœ… Generated ABC sharp texture: ${name}`);
        } catch (error) {
          console.error(`âŒ Error generating ABC sharp texture for ${name}:`, error);
        }
      });

      // ABC Flat ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
      flatNamesABC.forEach(name => {
        try {
          const text = new PIXI.Text(name, labelStyle);
          const texture = this.app.renderer.generateTexture(text);
          
          if (!texture || texture === PIXI.Texture.EMPTY) {
            console.warn(`âš ï¸ Failed to generate texture for ABC flat: ${name}`);
            return;
          }
          
          this.labelTextures.abc_flat.set(name, texture);
          text.destroy();
          console.log(`âœ… Generated ABC flat texture: ${name}`);
        } catch (error) {
          console.error(`âŒ Error generating ABC flat texture for ${name}:`, error);
        }
      });

      // Solfege Sharp ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
      sharpNamesSolfege.forEach(name => {
        try {
          const text = new PIXI.Text(name, labelStyle);
          const texture = this.app.renderer.generateTexture(text);
          
          if (!texture || texture === PIXI.Texture.EMPTY) {
            console.warn(`âš ï¸ Failed to generate texture for Solfege sharp: ${name}`);
            return;
          }
          
          this.labelTextures.solfege_sharp.set(name, texture);
          text.destroy();
          console.log(`âœ… Generated Solfege sharp texture: ${name}`);
        } catch (error) {
          console.error(`âŒ Error generating Solfege sharp texture for ${name}:`, error);
        }
      });

      // Solfege Flat ãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆ
      flatNamesSolfege.forEach(name => {
        try {
          const text = new PIXI.Text(name, labelStyle);
          const texture = this.app.renderer.generateTexture(text);
          
          if (!texture || texture === PIXI.Texture.EMPTY) {
            console.warn(`âš ï¸ Failed to generate texture for Solfege flat: ${name}`);
            return;
          }
          
          this.labelTextures.solfege_flat.set(name, texture);
          text.destroy();
          console.log(`âœ… Generated Solfege flat texture: ${name}`);
        } catch (error) {
          console.error(`âŒ Error generating Solfege flat texture for ${name}:`, error);
        }
      });
      
      console.log(`ğŸ¯ Label texture generation completed! Total textures: ${
        this.labelTextures.abc_sharp.size + 
        this.labelTextures.abc_flat.size + 
        this.labelTextures.solfege_sharp.size + 
        this.labelTextures.solfege_flat.size
      }`);
      
    } catch (error) {
      console.error('âŒ Critical error in generateLabelTextures:', error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç©ºã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ãƒãƒƒãƒ—ã‚’ä½œæˆ
      this.labelTextures = {
        abc_sharp: new Map(),
        abc_flat: new Map(), 
        solfege_sharp: new Map(),
        solfege_flat: new Map()
      };
    }
  }

  /**
   * éŸ³åã«å¯¾å¿œã™ã‚‹ãƒ©ãƒ™ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’å–å¾—
   */
  private getLabelTexture(noteName: string): PIXI.Texture | null {
    if (!noteName || this.settings.noteNameStyle === 'off') {
      console.log(`ğŸ” getLabelTexture: Skipping empty note name or style is off`);
      return null;
    }

    // ãƒ©ãƒ™ãƒ«ãƒ†ã‚¯ã‚¹ãƒãƒ£ãŒåˆæœŸåŒ–ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
    if (!this.labelTextures) {
      console.error('âŒ getLabelTexture: labelTextures not initialized!');
      return null;
    }

    const style = this.settings.noteNameStyle;
    const accidental = this.settings.noteAccidentalStyle;

    let textureMap: Map<string, PIXI.Texture>;

    if (style === 'abc') {
      textureMap = accidental === 'flat' ? this.labelTextures.abc_flat : this.labelTextures.abc_sharp;
    } else if (style === 'solfege') {
      textureMap = accidental === 'flat' ? this.labelTextures.solfege_flat : this.labelTextures.solfege_sharp;
    } else {
      textureMap = this.labelTextures.abc_sharp; // fallback
    }

    const texture = textureMap.get(noteName);
    
    if (!texture) {
      console.warn(`âš ï¸ getLabelTexture: No texture found for "${noteName}" (style: ${style}, accidental: ${accidental})`);
      console.log(`Available textures in map:`, Array.from(textureMap.keys()));
      return null;
    }

    if (texture === PIXI.Texture.EMPTY) {
      console.warn(`âš ï¸ getLabelTexture: Found empty texture for "${noteName}"`);
      return null;
    }

    console.log(`âœ… getLabelTexture: Found texture for "${noteName}" (${texture.width}x${texture.height})`);
    return texture;
  }

  /**
   * ãƒ©ãƒ™ãƒ«ã‚³ãƒ³ãƒ†ãƒŠã‚’ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼ˆé€šå¸¸ã®Containerã«å¤‰æ›´ï¼‰
   */
  private fallbackToRegularLabelContainer(): void {
    if (this.labelContainerFallback) return; // æ—¢ã«ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯æ¸ˆã¿
    
    console.warn('ğŸ”„ Falling back to regular Container for labels due to ParticleContainer issues');
    
    try {
      // æ—¢å­˜ã®ParticleContainerã‚’å‰Šé™¤
      if (this.labelsContainer && this.labelsContainer.parent) {
        this.labelsContainer.parent.removeChild(this.labelsContainer);
        this.labelsContainer.destroy();
      }
      
      // æ–°ã—ã„é€šå¸¸ã®Containerã‚’ä½œæˆ
      this.labelsContainer = new PIXI.Container() as any;
      this.container.addChild(this.labelsContainer);
      
      this.labelContainerFallback = true;
      console.log('âœ… Successfully created fallback regular Container for labels');
      
    } catch (error) {
      console.error('âŒ Failed to create fallback container:', error);
    }
  }
  
  /**
   * Graphics ã«æç”»ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ç”Ÿæˆç”¨ï¼‰
   */
  private drawNoteShapeToGraphics(graphics: PIXI.Graphics, state: ActiveNote['state'], isBlackKey: boolean, noteWidth?: number, noteHeight?: number): void {
    graphics.clear();
    
    // ã‚µã‚¤ã‚ºã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯settingsã‹ã‚‰å–å¾—
    const width = noteWidth ?? this.settings.noteWidth;
    const height = noteHeight ?? this.settings.noteHeight;
    
    // GOOD åˆ¤å®šï¼ˆstate === 'hit') ã§ã¯ãƒãƒ¼ãƒ„ã‚’é€æ˜ã«ã™ã‚‹
    if (state === 'hit') {
      // é€æ˜åŒ–ã—ã¦ã‚¹ãƒšãƒ¼ã‚¹ã‚’æ®‹ã™ï¼ˆã‚¯ãƒªãƒƒã‚¯åˆ¤å®šãªã©å½±éŸ¿ã•ã›ãªã„ï¼‰
      graphics.beginFill(0x000000, 0);
      graphics.drawRect(-width / 2, -height / 2, width, height);
      graphics.endFill();
      return;
    }

    // ã‚ˆã‚Šç¾ã—ã„ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’å†ç¾
    if (state === 'visible') {
      if (isBlackKey) {
        // é»’éµãƒãƒ¼ãƒ„ï¼ˆç´«ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        const steps = 8;
        const stepHeight = height / steps;
        
        for (let i = 0; i < steps; i++) {
          const progress = i / (steps - 1);
          
          // ç´«ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
          const r1 = 0x4C, g1 = 0x1D, b1 = 0x95; // purple-800
          const r2 = 0x7C, g2 = 0x3A, b2 = 0xED; // purple-600
          
          const r = Math.round(r1 + (r2 - r1) * progress);
          const g = Math.round(g1 + (g2 - g1) * progress);
          const b = Math.round(b1 + (b2 - b1) * progress);
          
          const color = (r << 16) | (g << 8) | b;
          const alpha = 0.9 + 0.05 * progress;
          
          graphics.beginFill(color, alpha);
          graphics.drawRoundedRect(
            -width / 2,
            -height / 2 + i * stepHeight,
            width,
            stepHeight + 1,
            i === 0 ? 4 : 0
          );
          graphics.endFill();
        }
        
        // ç´«ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœ
        graphics.beginFill(0x9333EA, 0.4);
        graphics.drawRoundedRect(
          -width / 2,
          -height / 2,
          width,
          height / 3,
          4
        );
        graphics.endFill();
        
        // ç´«ã®è¼ªéƒ­ç·š
        graphics.lineStyle(1, 0x8B5CF6, 0.8);
        graphics.drawRoundedRect(-width / 2, -height / 2, width, height, 4);
      } else {
        // ç™½éµãƒãƒ¼ãƒ„ï¼ˆé’ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³ï¼‰
        const steps = 8;
        const stepHeight = height / steps;
        
        for (let i = 0; i < steps; i++) {
          const progress = i / (steps - 1);
          
          // é’ç³»ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
          const r1 = 0x16, g1 = 0x21, b1 = 0x3E; // topColor RGB
          const r2 = 0x0F, g2 = 0x34, b2 = 0x60; // bottomColor RGB
          
          const r = Math.round(r1 + (r2 - r1) * progress);
          const g = Math.round(g1 + (g2 - g1) * progress);
          const b = Math.round(b1 + (b2 - b1) * progress);
          
          const color = (r << 16) | (g << 8) | b;
          const alpha = 0.9 + 0.05 * progress;
          
          graphics.beginFill(color, alpha);
          graphics.drawRoundedRect(
            -width / 2,
            -height / 2 + i * stepHeight,
            width,
            stepHeight + 1,
            i === 0 ? 4 : 0
          );
          graphics.endFill();
        }
        
        // é’ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœ
        graphics.beginFill(0x667EEA, 0.3);
        graphics.drawRoundedRect(
          -width / 2,
          -height / 2,
          width,
          height / 3,
          4
        );
        graphics.endFill();
        
        // é’ã®è¼ªéƒ­ç·š
        graphics.lineStyle(1, 0x4F46E5, 0.8);
        graphics.drawRoundedRect(-width / 2, -height / 2, width, height, 4);
      }
    } else {
      const color = this.getStateColor(state);
      graphics.beginFill(color);
      graphics.drawRoundedRect(-width / 2, -height / 2, width, height, 4);
      graphics.endFill();
      
      // è¼ªéƒ­ç·š
      graphics.lineStyle(1, color, 0.8);
      graphics.drawRoundedRect(-width / 2, -height / 2, width, height, 4);
    }
  }
  
  private setupContainers(): void {
    // ãƒ¡ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠã‚’ç”Ÿæˆ
    this.container = new PIXI.Container();
    this.app.stage.addChild(this.container);

    // Zé †: èƒŒé¢ â†’ å‰é¢

    // 1. ãƒ”ã‚¢ãƒã‚³ãƒ³ãƒ†ãƒŠï¼ˆæœ€èƒŒé¢ï¼‰
    this.pianoContainer = new PIXI.Container();
    this.container.addChild(this.pianoContainer);

    // 2. ãƒãƒ¼ãƒ„ã‚³ãƒ³ãƒ†ãƒŠï¼ˆParticleContainer ã«å¤‰æ›´ï¼‰
    this.notesContainer = new PIXI.ParticleContainer(
      5000, // æœ€å¤§5000å€‹ã®ãƒãƒ¼ãƒ„ã‚’ã‚µãƒãƒ¼ãƒˆ
      { 
        position: true, 
        tint: true, 
        alpha: true,
        scale: true
      }
    );
    this.container.addChild(this.notesContainer);

    // 3. ãƒ©ãƒ™ãƒ«å°‚ç”¨ã‚³ãƒ³ãƒ†ãƒŠï¼ˆParticleContainer ã«å¤‰æ›´ã§æœ€é©åŒ–ï¼‰
    this.labelsContainer = new PIXI.ParticleContainer(
      5000, // æœ€å¤§5000å€‹ã®ãƒ©ãƒ™ãƒ«ã‚’ã‚µãƒãƒ¼ãƒˆ
      { 
        position: true, 
        tint: true, 
        alpha: true,
        scale: true
      }
    );
    this.container.addChild(this.labelsContainer);

    // 4. ãƒ’ãƒƒãƒˆãƒ©ã‚¤ãƒ³ã‚³ãƒ³ãƒ†ãƒŠï¼ˆãƒãƒ¼ãƒ„ä¸Šã€ã‚¨ãƒ•ã‚§ã‚¯ãƒˆä¸‹ï¼‰
    this.hitLineContainer = new PIXI.Container();
    this.container.addChild(this.hitLineContainer);

    // 5. ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚³ãƒ³ãƒ†ãƒŠï¼ˆæœ€å‰é¢ï¼‰
    this.effectsContainer = new PIXI.Container();
    this.container.addChild(this.effectsContainer);
  }
  
  private setupHitLine(): void {
    const hitLine = new PIXI.Graphics();
    hitLine.lineStyle(3, 0xFBBF24); // amber-400
    hitLine.moveTo(0, this.settings.hitLineY);
    hitLine.lineTo(this.app.screen.width, this.settings.hitLineY);
    
    // ã‚°ãƒ­ãƒ¼åŠ¹æœ
    const glowLine = new PIXI.Graphics();
    glowLine.lineStyle(6, 0xFBBF24, 0.5);
    glowLine.moveTo(0, this.settings.hitLineY);
    glowLine.lineTo(this.app.screen.width, this.settings.hitLineY);
    
    this.hitLineContainer.addChild(glowLine);
    this.hitLineContainer.addChild(hitLine);
  }
  
  private setupPiano(): void {
    // ãƒ”ã‚¢ãƒèƒŒæ™¯ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’è¿½åŠ 
    this.createPianoBackground();
    
    // 88éµãƒ”ã‚¢ãƒã®æç”»ï¼ˆA0=21 to C8=108ï¼‰
    const minNote = 21;
    const maxNote = 108;
    
    // ç™½éµã®ç·æ•°ã‚’è¨ˆç®—
    let totalWhiteKeys = 0;
    for (let note = minNote; note <= maxNote; note++) {
      if (!this.isBlackKey(note)) {
        totalWhiteKeys++;
      }
    }
    
    const whiteKeyWidth = this.app.screen.width / totalWhiteKeys;
    
    // ç™½éµã‚³ãƒ³ãƒ†ãƒŠã¨é»’éµã‚³ãƒ³ãƒ†ãƒŠã‚’åˆ†é›¢ã—ã¦ Z-index ã‚’ç¢ºå®Ÿã«åˆ¶å¾¡
    const whiteKeysContainer = new PIXI.Container();
    const blackKeysContainer = new PIXI.Container();
    
    // ç™½éµã‚’æç”»
    let whiteKeyIndex = 0;
    for (let note = minNote; note <= maxNote; note++) {
      if (!this.isBlackKey(note)) {
        const whiteKey = this.createWhiteKey(whiteKeyIndex * whiteKeyWidth, whiteKeyWidth, note);
        whiteKeysContainer.addChild(whiteKey);
        this.pianoSprites.set(note, whiteKey);
        whiteKeyIndex++;
      }
    }
    
    // é»’éµã‚’æç”»ï¼ˆç™½éµã®ä¸Šã€æ­£ç¢ºãªä½ç½®è¨ˆç®—ï¼‰
    for (let note = minNote; note <= maxNote; note++) {
      if (this.isBlackKey(note)) {
        const position = this.calculateBlackKeyPosition(note, minNote, maxNote, totalWhiteKeys);
        const blackKey = this.createBlackKey(
          position, 
          whiteKeyWidth, // ç™½éµã®å¹…ã‚’æ¸¡ã—ã€createBlackKeyå†…ã§æ¯”ç‡è¨ˆç®—
          note
        );
        blackKeysContainer.addChild(blackKey);
        this.pianoSprites.set(note, blackKey);
      }
    }
    
    // ã‚³ãƒ³ãƒ†ãƒŠã‚’é †åºä»˜ã‘ã¦è¿½åŠ ï¼ˆç™½éµãŒèƒŒé¢ã€é»’éµãŒå‰é¢ï¼‰
    this.pianoContainer.addChild(whiteKeysContainer);
    this.pianoContainer.addChild(blackKeysContainer);
    
    // ===== ã‚°ãƒªãƒƒã‚µãƒ³ãƒ‰ç”¨ãƒ‰ãƒ©ãƒƒã‚°ãƒãƒ³ãƒ‰ãƒ© =====
    this.pianoContainer.eventMode = 'static';
    this.pianoContainer.on('pointerdown', this.handleDragStart.bind(this));
    this.pianoContainer.on('pointermove', this.handleDragMove.bind(this));
    this.pianoContainer.on('pointerup', this.handleDragEnd.bind(this));
    this.pianoContainer.on('pointerupoutside', this.handleDragEnd.bind(this));
    this.pianoContainer.on('pointercancel', this.handleDragEnd.bind(this));
  }
  
  /**
   * ãƒãƒ¼ãƒ„é™ä¸‹ã‚¨ãƒªã‚¢ã®å®‡å®™çš„èƒŒæ™¯ã¨ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’ä½œæˆ
   */
  private createNotesAreaBackground(): void {
    // === å®‡å®™çš„ãƒ›ãƒ©ã‚¤ã‚ºãƒ³ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³èƒŒæ™¯ ===
    const background = new PIXI.Graphics();
    const steps = 50; // ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    const stepHeight = this.settings.hitLineY / steps;
    
    for (let i = 0; i < steps; i++) {
      const progress = i / (steps - 1);
      
      // å®‡å®™çš„ãªè‰²ã®é·ç§»: æ·±ã„ç´«ã‹ã‚‰æ˜Ÿç©ºã®é’ã€ãã—ã¦åœ°å¹³ç·šã®èµ¤ç´«ã¸
      // ä¸Šéƒ¨: æ·±ã„å®‡å®™ã®ç´« (æ·±ã„ç´º)
      // ä¸­å¤®: æ˜Ÿé›²ã®é’ç´«
      // ä¸‹éƒ¨: åœ°å¹³ç·šã®æš–ã‹ã„ç´«
      const r1 = 10, g1 = 5, b1 = 25;    // æ·±ã„å®‡å®™ã®ç´«ï¼ˆä¸Šéƒ¨ï¼‰
      const r2 = 25, g2 = 15, b2 = 45;   // ä¸­é–“ã®é’ç´«
      const r3 = 45, g3 = 20, b3 = 35;   // åœ°å¹³ç·šã®æš–ã‹ã„ç´«ï¼ˆä¸‹éƒ¨ï¼‰
      
      let r, g, b;
      if (progress < 0.5) {
        // ä¸ŠåŠåˆ†: æ·±ã„å®‡å®™ã‹ã‚‰ä¸­é–“è‰²ã¸
        const localProgress = progress * 2;
        r = Math.round(r1 + (r2 - r1) * localProgress);
        g = Math.round(g1 + (g2 - g1) * localProgress);
        b = Math.round(b1 + (b2 - b1) * localProgress);
      } else {
        // ä¸‹åŠåˆ†: ä¸­é–“è‰²ã‹ã‚‰åœ°å¹³ç·šã¸
        const localProgress = (progress - 0.5) * 2;
        r = Math.round(r2 + (r3 - r2) * localProgress);
        g = Math.round(g2 + (g3 - g2) * localProgress);
        b = Math.round(b2 + (b3 - b2) * localProgress);
      }
      
      const color = (r << 16) | (g << 8) | b;
      const alpha = 0.9 + 0.1 * progress; // ä¸‹éƒ¨ã«å‘ã‹ã£ã¦å°‘ã—æ¿ƒã
      
      background.beginFill(color, alpha);
      background.drawRect(0, i * stepHeight, this.app.screen.width, stepHeight + 1);
      background.endFill();
    }
    
    // æ˜Ÿã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’è¿½åŠ 
    this.createStarField(background);
    
    this.container.addChildAt(background, 0); // æœ€èƒŒé¢ã«é…ç½®
    
    // === ç¸¦ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ï¼ˆç™½éµãƒ¬ãƒ¼ãƒ³ï¼‰===
    this.createVerticalGuidelines();
  }
  
  /**
   * æ˜Ÿç©ºã‚¨ãƒ•ã‚§ã‚¯ãƒˆã‚’ä½œæˆ
   */
  private createStarField(background: PIXI.Graphics): void {
    const starCount = 80;
    
    for (let i = 0; i < starCount; i++) {
      const x = Math.random() * this.app.screen.width;
      const y = Math.random() * this.settings.hitLineY;
      const size = Math.random() * 2 + 0.5;
      const brightness = Math.random() * 0.8 + 0.2;
      
      // æ˜Ÿã®è‰²ã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«ï¼ˆé’ç™½ã€ç™½ã€è–„ç´«ï¼‰
      const starColors = [0xFFFFFF, 0xE0E7FF, 0xDDD6FE, 0xFAF5FF];
      const color = starColors[Math.floor(Math.random() * starColors.length)];
      
      background.beginFill(color, brightness);
      background.drawCircle(x, y, size);
      background.endFill();
      
      // è¼ãæ˜Ÿï¼ˆå¤§ãã‚ï¼‰
      if (Math.random() < 0.1) {
        background.beginFill(color, brightness * 0.3);
        background.drawCircle(x, y, size * 3);
        background.endFill();
      }
    }
  }
  
  /**
   * ç™½éµã«åˆã‚ã›ãŸç¸¦ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’ä½œæˆï¼ˆç°¡ç´ åŒ–ç‰ˆï¼‰
   */
  private createVerticalGuidelines(): void {
    const guidelines = new PIXI.Graphics();
    
    // 88éµãƒ”ã‚¢ãƒã®è¨­å®š
    const minNote = 21; // A0
    const maxNote = 108; // C8
    
    // ç™½éµã®ç·æ•°ã‚’è¨ˆç®—
    let totalWhiteKeys = 0;
    for (let note = minNote; note <= maxNote; note++) {
      if (!this.isBlackKey(note)) {
        totalWhiteKeys++;
      }
    }
    
    const whiteKeyWidth = this.app.screen.width / totalWhiteKeys;
    
    // ã‚ªã‚¯ã‚¿ãƒ¼ãƒ–ã®Cãƒãƒ¼ãƒˆã®ã¿ã«ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’æç”»ï¼ˆè¦–è¦šçš„ãªç›®å®‰ï¼‰
    let whiteKeyIndex = 0;
    for (let note = minNote; note <= maxNote; note++) {
      if (!this.isBlackKey(note)) {
        const x = whiteKeyIndex * whiteKeyWidth;
        
        // å…¨ã¦ã®ç™½éµã«å¢ƒç•Œç·šã‚’æç”»
        const noteName = this.getMidiNoteName(note);
        const isOctaveMarker = noteName === 'C';
        
        // Cãƒãƒ¼ãƒˆã¯å°‘ã—æ¿ƒãã€ä»–ã¯è–„ã
        const lineWidth = isOctaveMarker ? 2 : 1;
        const alpha = isOctaveMarker ? 0.4 : 0.15;
        const color = isOctaveMarker ? 0x8B5CF6 : 0x6B7280;
        
        guidelines.lineStyle(lineWidth, color, alpha);
        guidelines.moveTo(x, 0);
        guidelines.lineTo(x, this.settings.hitLineY);
        
        whiteKeyIndex++;
      }
    }
    
    // ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã¯ Graphics ãªã®ã§ ParticleContainer ã§ã¯ãªãé€šå¸¸ã®ã‚³ãƒ³ãƒ†ãƒŠã«è¿½åŠ 
    // ãƒãƒ¼ãƒ„ã®å¾Œã‚ã«é…ç½®ã™ã‚‹ãŸã‚ã€notesContainer ã®ç›´å‰ã«æŒ¿å…¥
    const notesIndex = this.container.getChildIndex(this.notesContainer);
    this.container.addChildAt(guidelines, notesIndex);
  }
  
  /**
   * ãƒ”ã‚¢ãƒèƒŒæ™¯ã®ã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’ä½œæˆ
   */
  private createPianoBackground(): void {
    const background = new PIXI.Graphics();
    
    // ã‚ˆã‚Šæ»‘ã‚‰ã‹ãªã‚°ãƒ©ãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœã‚’ä½œæˆ
    const steps = 10;
    const stepHeight = this.settings.pianoHeight / steps;
    
    for (let i = 0; i < steps; i++) {
      const progress = i / (steps - 1);
      
      // ãƒ”ã‚¢ãƒéƒ¨åˆ†ã¯æš–ã‹ã„è‰²èª¿ã§èƒŒæ™¯ã¨èª¿å’Œ
      const r1 = 30, g1 = 25, b1 = 50;   // ä¸Šéƒ¨ï¼šæ·±ã„ç´«
      const r2 = 20, g2 = 30, b2 = 60;   // ä¸‹éƒ¨ï¼šæ¿ƒã„é’ç´«
      
      const r = Math.round(r1 + (r2 - r1) * progress);
      const g = Math.round(g1 + (g2 - g1) * progress);
      const b = Math.round(b1 + (b2 - b1) * progress);
      
      const color = (r << 16) | (g << 8) | b;
      const alpha = 0.8 + 0.1 * progress; // é€æ˜åº¦ã‚’ä¸‹ã’ã¦åˆ¤å®šãƒ©ã‚¤ãƒ³ã‚’è¦‹ã‚„ã™ã
      
      background.beginFill(color, alpha);
      background.drawRect(0, i * stepHeight, this.app.screen.width, stepHeight + 1);
      background.endFill();
    }
    
    // ãƒ”ã‚¢ãƒèƒŒæ™¯ã®ä½ç½®è¨­å®š - ç”»é¢åº•éƒ¨ã«å›ºå®š
    background.x = 0;
    background.y = this.settings.hitLineY;
    
    this.pianoContainer.addChild(background);
  }
  
  private setupParticles(): void {
    // é€šå¸¸ã®ã‚³ãƒ³ãƒ†ãƒŠã‚’ä½¿ç”¨ï¼ˆPIXI.Graphicsã¨ã®äº’æ›æ€§ã®ãŸã‚ï¼‰
    this.particles = new PIXI.Container();
    this.effectsContainer.addChild(this.particles);
  }
  
  private setupLightweightEffectsTicker(): void {
    // **è»½é‡ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚£ãƒƒã‚«ãƒ¼ - ãƒãƒ¼ãƒ„ä½ç½®æ›´æ–°ã¯è¡Œã‚ãªã„**
    // ç«¶åˆãƒ«ãƒ¼ãƒ—å›é¿ï¼šPIXIã¯ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã¿ã€ãƒãƒ¼ãƒ„ä½ç½®ã¯updateNotesã§ç®¡ç†
    
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå°‚ç”¨ã®è»½é‡ãƒ†ã‚£ãƒƒã‚«ãƒ¼ï¼ˆä½é »åº¦æ›´æ–°ï¼‰
    const effectsTicker = () => {
      const currentFrameTime = performance.now();
      
      // 30FPSã§ã‚¨ãƒ•ã‚§ã‚¯ãƒˆæ›´æ–°ï¼ˆãƒãƒ¼ãƒ„ã‚ˆã‚Šä½é »åº¦ï¼‰
      if (currentFrameTime - this.lastFrameTime < 33) {
        requestAnimationFrame(effectsTicker);
        return;
      }
      
      const deltaTime = (currentFrameTime - this.lastFrameTime) / 1000;
      this.lastFrameTime = currentFrameTime;
      
      // ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã¿æ›´æ–°ï¼ˆè»½é‡åŒ–ï¼‰
      if (this.settings.effects.particles) {
        this.updateParticleEffects(deltaTime);
      }
      
      requestAnimationFrame(effectsTicker);
    };
    
    // ã‚¨ãƒ•ã‚§ã‚¯ãƒˆãƒ†ã‚£ãƒƒã‚«ãƒ¼é–‹å§‹
    requestAnimationFrame(effectsTicker);
  }
  
  private updateParticleEffects(deltaTime: number): void {
    const childrenToRemove: PIXI.DisplayObject[] = [];
    const maxProcessPerFrame = 10; // 1ãƒ•ãƒ¬ãƒ¼ãƒ ã‚ãŸã‚Šã®æœ€å¤§å‡¦ç†æ•°
    let processed = 0;
    
    for (const child of this.effectsContainer.children) {
      if (processed >= maxProcessPerFrame) break;
      
      if (child.alpha > 0) {
        child.alpha -= deltaTime * 2; // ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆ
        if (child.alpha <= 0) {
          childrenToRemove.push(child);
        }
      }
      processed++;
    }
    
    // å®‰å…¨ã«å‰Šé™¤ï¼ˆãƒãƒƒãƒå‡¦ç†ï¼‰
    for (const child of childrenToRemove) {
      try {
        if (child.parent) {
          child.parent.removeChild(child);
        }
        if (!child.destroyed) {
          child.destroy({ children: true, texture: false, baseTexture: false });
        }
      } catch (error) {
        console.warn('âš ï¸ Particle cleanup error:', error);
      }
    }
  }
  
  private createWhiteKey(x: number, width: number, midiNote?: number): PIXI.Graphics {
    const key = new PIXI.Graphics();
    key.beginFill(this.settings.colors.whiteKey);
    key.lineStyle(1, 0x000000, 0.3);
    key.drawRect(0, 0, width - 1, this.settings.pianoHeight);
    key.endFill();
    key.x = x;
    key.y = this.settings.hitLineY; // åˆ¤å®šãƒ©ã‚¤ãƒ³ä½ç½®ã‹ã‚‰é–‹å§‹
    
    // éŸ³åè¡¨ç¤ºã‚’è¿½åŠ ï¼ˆç™½éµã®ã¿ï¼‰
    if (midiNote !== undefined && !this.isBlackKey(midiNote)) {
      const _noteName = this.getMidiNoteName(midiNote);
      const text = new PIXI.Text(_noteName, {
        fontSize: Math.min(width * 0.25, 12),
        fill: 0x666666,
        fontFamily: 'Arial, sans-serif',
        fontWeight: 'bold',
        align: 'center'
      });
      
      // ãƒ†ã‚­ã‚¹ãƒˆã‚’ä¸­å¤®ã«é…ç½®
      text.anchor.set(0.5, 1);
      text.x = width / 2;
      text.y = this.settings.pianoHeight - 8;
      key.addChild(text);
    }
    
          // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³è¨­å®šã‚’å¼·åŒ–
      if (midiNote !== undefined) {
        key.eventMode = 'static';
        key.cursor = 'pointer';
      
      // ã‚ˆã‚Šç¢ºå®Ÿãªã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
      key.on('pointerdown', (event) => {
        event.stopPropagation();
        this.handleKeyPress(midiNote);
      });
      
      key.on('pointerup', (event) => {
        event.stopPropagation();
        this.handleKeyRelease(midiNote);
      });
      
      // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ
      key.on('touchstart', (event) => {
        event.stopPropagation();
        this.handleKeyPress(midiNote);
      });
      
      key.on('touchend', (event) => {
        event.stopPropagation();
        this.handleKeyRelease(midiNote);
      });
      
      // ãƒ›ãƒãƒ¼åŠ¹æœã‚’è¿½åŠ 
      key.on('pointerover', () => {
        key.tint = 0xF3F4F6; // light gray hover
      });
      
      key.on('pointerout', () => {
        key.tint = 0xFFFFFF; // white
      });
    }
    
    return key;
  }
  
  private createBlackKey(x: number, width: number, midiNote?: number): PIXI.Graphics {
    const key = new PIXI.Graphics();
    
    // é»’éµã®å¹…ã‚’æ‹¡å¤§ã—ã¦ã‚¯ãƒªãƒƒã‚¯ã—ã‚„ã™ãã™ã‚‹ï¼ˆç™½éµã®80%ï¼‰
    const blackKeyWidthRatio = 0.8;
    const adjustedWidth = width * blackKeyWidthRatio;
    const blackKeyHeight = this.settings.pianoHeight * 0.65; // é«˜ã•ã‚‚è‹¥å¹²æ‹¡å¤§
    
    // é»’éµã®å½±ï¼ˆèƒŒé¢ï¼‰
    key.beginFill(0x000000, 0.3); // è–„ã„é»’ã®å½±
    key.drawRect(-adjustedWidth * 0.75 / 2 + 1, 1, adjustedWidth * 0.75, blackKeyHeight); // å°‘ã—ã‚ªãƒ•ã‚»ãƒƒãƒˆ
    key.endFill();
    
    // è¦–è¦šçš„ãªé»’éµï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰- ç´”ç²‹ãªé»’è‰²
    key.beginFill(this.settings.colors.blackKey); // ç´”ç²‹ãªé»’è‰²
    key.drawRect(-adjustedWidth * 0.75 / 2, 0, adjustedWidth * 0.75, blackKeyHeight);
    key.endFill();
    
    // é»’éµã®ä¸Šç«¯ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆå¾®å¦™ãªå…‰æ²¢åŠ¹æœï¼‰
    key.beginFill(0x333333, 0.6); // è–„ã„ã‚°ãƒ¬ãƒ¼
    key.drawRect(-adjustedWidth * 0.75 / 2, 0, adjustedWidth * 0.75, 2);
    key.endFill();
    
    // ã‚¯ãƒªãƒƒã‚¯é ˜åŸŸï¼ˆå®Œå…¨é€æ˜ã€è¦–è¦šçš„å½±éŸ¿ãªã—ï¼‰
    key.beginFill(0x000000, 0.0); // å®Œå…¨é€æ˜
    key.drawRect(-adjustedWidth / 2, 0, adjustedWidth, blackKeyHeight);
    key.endFill();
    
    key.x = x;
    key.y = this.settings.hitLineY; // åˆ¤å®šãƒ©ã‚¤ãƒ³ä½ç½®ã‹ã‚‰é–‹å§‹
    
          // ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³è¨­å®šã‚’å¼·åŒ–
      if (midiNote !== undefined) {
        key.eventMode = 'static';
        key.cursor = 'pointer';
      
              // ã‚ˆã‚Šç¢ºå®Ÿãªã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
        key.on('pointerdown', (event) => {
          event.stopPropagation();
          this.handleKeyPress(midiNote);
        });
      
      key.on('pointerup', (event) => {
        event.stopPropagation();
        this.handleKeyRelease(midiNote);
      });
      
      // ã‚¿ãƒƒãƒãƒ‡ãƒã‚¤ã‚¹å¯¾å¿œ
      key.on('touchstart', (event) => {
        event.stopPropagation();
        this.handleKeyPress(midiNote);
      });
      
      key.on('touchend', (event) => {
        event.stopPropagation();
        this.handleKeyRelease(midiNote);
      });
      
      // ãƒ›ãƒãƒ¼åŠ¹æœã‚’è¿½åŠ ï¼ˆé»’éµå°‚ç”¨ã€tintã§ã¯ãªãè»½å¾®ãªè¦–è¦šåŠ¹æœã®ã¿ï¼‰
      key.on('pointerover', () => {
        // é»’éµã®ãƒ›ãƒãƒ¼åŠ¹æœã¯å¾®å¦™ã«ã—ã¦ã€ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’é˜»å®³ã—ãªã„
        if (!this.isKeyHighlighted(midiNote)) {
          key.alpha = 0.8; // å°‘ã—é€æ˜ã«ã—ã¦ãƒ›ãƒãƒ¼æ„Ÿã‚’æ¼”å‡º
        }
      });
      
      key.on('pointerout', () => {
        // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã§ãªã„å ´åˆã®ã¿ãƒªã‚»ãƒƒãƒˆ
        if (!this.isKeyHighlighted(midiNote)) {
          key.alpha = 1.0; // é€šå¸¸çŠ¶æ…‹ã«æˆ»ã™
        }
      });
    }
    
    return key;
  }
  
  /**
   * MIDIãƒãƒ¼ãƒˆç•ªå·ã‹ã‚‰éŸ³åã‚’å–å¾—ï¼ˆçµ±ä¸€ã•ã‚ŒãŸè¨­å®šã‚’ä½¿ç”¨ï¼‰
   */
  private getMidiNoteName(midiNote: number): string {
    // çµ±ä¸€ã•ã‚ŒãŸè¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ«ã‚’å–å¾—
    const style = this.settings.noteNameStyle;
    const accidental = this.settings.noteAccidentalStyle;

    if (style === 'off') return '';

    // 12éŸ³éšã®åå‰ãƒ†ãƒ¼ãƒ–ãƒ«
    const sharpNamesABC = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const flatNamesABC  = ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'];

    const sharpNamesSolfege = ['ãƒ‰', 'ãƒ‰#', 'ãƒ¬', 'ãƒ¬#', 'ãƒŸ', 'ãƒ•ã‚¡', 'ãƒ•ã‚¡#', 'ã‚½', 'ã‚½#', 'ãƒ©', 'ãƒ©#', 'ã‚·'];
    const flatNamesSolfege  = ['ãƒ‰', 'ãƒ¬â™­', 'ãƒ¬', 'ãƒŸâ™­', 'ãƒŸ', 'ãƒ•ã‚¡', 'ã‚½â™­', 'ã‚½', 'ãƒ©â™­', 'ãƒ©', 'ã‚·â™­', 'ã‚·'];

    const index = midiNote % 12;

    if (style === 'abc') {
      return accidental === 'flat' ? flatNamesABC[index] : sharpNamesABC[index];
    }
    if (style === 'solfege') {
      return accidental === 'flat' ? flatNamesSolfege[index] : sharpNamesSolfege[index];
    }

    // fallback
    return sharpNamesABC[index];
  }
  
  private isBlackKey(midiNote: number): boolean {
    const noteInOctave = midiNote % 12;
    return [1, 3, 6, 8, 10].includes(noteInOctave);
  }
  
  /**
   * ã‚­ãƒ¼ãŒãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‹ã©ã†ã‹ã‚’ç¢ºèª
   */
  private isKeyHighlighted(midiNote: number): boolean {
    return this.highlightedKeys.has(midiNote);
  }
  
  private calculateBlackKeyPosition(note: number, minNote: number, _maxNote: number, totalWhiteKeys: number): number {
    const noteInOctave = note % 12;
    
    // éš£æ¥ã™ã‚‹ç™½éµã®MIDIãƒãƒ¼ãƒˆç•ªå·ã‚’ç‰¹å®š
    let prevWhiteNote: number, nextWhiteNote: number;
    
    switch (noteInOctave) {
      case 1:  // C#
        prevWhiteNote = note - 1;  // C
        nextWhiteNote = note + 1;  // D
        break;
      case 3:  // D#
        prevWhiteNote = note - 1;  // D
        nextWhiteNote = note + 1;  // E
        break;
      case 6:  // F#
        prevWhiteNote = note - 1;  // F
        nextWhiteNote = note + 1;  // G
        break;
      case 8:  // G#
        prevWhiteNote = note - 1;  // G
        nextWhiteNote = note + 1;  // A
        break;
      case 10: // A#
        prevWhiteNote = note - 1;  // A
        nextWhiteNote = note + 1;  // B
        break;
      default:
        console.error(`âŒ Invalid black key note: ${note}`);
        return 0; // ç„¡åŠ¹ãªé»’éµ
    }
    
    // Piano.tsã¨åŒã˜ãƒ­ã‚¸ãƒƒã‚¯ã§ç™½éµã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
    let prevWhiteKeyIndex = 0;
    for (let n = minNote; n < prevWhiteNote; n++) {
      if (!this.isBlackKey(n)) {
        prevWhiteKeyIndex++;
      }
    }
    
    let nextWhiteKeyIndex = 0;
    for (let n = minNote; n < nextWhiteNote; n++) {
      if (!this.isBlackKey(n)) {
        nextWhiteKeyIndex++;
      }
    }
    
    // ç™½éµã®å¹…ã‚’è¨ˆç®—
    const whiteKeyWidth = this.app.screen.width / totalWhiteKeys;
    
    // ã‚ˆã‚Šæ­£ç¢ºãªä½ç½®è¨ˆç®—
    // å·¦ã®ç™½éµã®ä¸­å¤®ä½ç½®
    const prevKeyCenter = (prevWhiteKeyIndex + 0.5) * whiteKeyWidth;
    
    // å³ã®ç™½éµã®ä¸­å¤®ä½ç½®
    const nextKeyCenter = (nextWhiteKeyIndex + 0.5) * whiteKeyWidth;
    
    // 2ã¤ã®ç™½éµã®ä¸­å¤®ä½ç½®ã®ä¸­ç‚¹ã‚’è¨ˆç®—
    const centerPosition = (prevKeyCenter + nextKeyCenter) / 2;
    
    return centerPosition;
  }
  
  /**
   * ãƒ”ã‚¢ãƒã‚­ãƒ¼ã®çŠ¶æ…‹æ›´æ–°ï¼ˆæ¼”å¥æ™‚ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼‰
   */
  highlightKey(midiNote: number, active: boolean): void {
    const keySprite = this.pianoSprites.get(midiNote);
    if (!keySprite) {
      console.warn(`âš ï¸ Key sprite not found for note: ${midiNote}`);
      return;
    }
    
    const isBlackKey = this.isBlackKey(midiNote);
    
    if (active) {
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã«è¿½åŠ 
      this.highlightedKeys.add(midiNote);
      
      if (isBlackKey) {
        // é»’éµã®ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼šã‚ªãƒ¬ãƒ³ã‚¸è‰²ã§å†æç”»
        this.redrawBlackKeyHighlight(keySprite, true);
      } else {
        // ç™½éµã®ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼štintã‚’ä½¿ç”¨
        keySprite.tint = this.settings.colors.activeKey;
      }
    } else {
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‹ã‚‰å‰Šé™¤
      this.highlightedKeys.delete(midiNote);
      
      if (isBlackKey) {
        // é»’éµã®é€šå¸¸çŠ¶æ…‹ï¼šå…ƒã®è‰²ã§å†æç”»
        this.redrawBlackKeyHighlight(keySprite, false);
        // ã‚¢ãƒ«ãƒ•ã‚¡å€¤ã‚‚ãƒªã‚»ãƒƒãƒˆ
        keySprite.alpha = 1.0;
      } else {
        // ç™½éµã®é€šå¸¸çŠ¶æ…‹ï¼štintã‚’ãƒªã‚»ãƒƒãƒˆ
        keySprite.tint = 0xFFFFFF;
      }
    }
  }
  
  /**
   * é»’éµã®ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ã‚’å†æç”»
   */
  private redrawBlackKeyHighlight(keySprite: PIXI.Graphics, highlighted: boolean): void {
    keySprite.clear();
    
    // åŸºæœ¬çš„ãªå¯¸æ³•ã‚’å†è¨ˆç®—ï¼ˆcreateBlackKeyã¨åŒã˜å€¤ï¼‰
    const whiteKeyWidth = this.app.screen.width / this.calculateTotalWhiteKeys();
    const blackKeyWidthRatio = 0.8;
    const adjustedWidth = whiteKeyWidth * blackKeyWidthRatio;
    const blackKeyHeight = this.settings.pianoHeight * 0.65;
    
    if (highlighted) {
      // ã‚ˆã‚Šé®®ã‚„ã‹ãªã‚ªãƒ¬ãƒ³ã‚¸è‰²ã®ã‚°ãƒ­ãƒ¼åŠ¹æœï¼ˆå¤–å´ï¼‰
      keySprite.beginFill(0xFF8C00, 0.6); // ã‚ˆã‚Šé®®ã‚„ã‹ãªã‚ªãƒ¬ãƒ³ã‚¸
      keySprite.drawRect(-adjustedWidth * 0.9 / 2, -2, adjustedWidth * 0.9, blackKeyHeight + 4);
      keySprite.endFill();
      
      // ãƒã‚¤ãƒ©ã‚¤ãƒˆçŠ¶æ…‹ï¼šé®®ã‚„ã‹ãªã‚ªãƒ¬ãƒ³ã‚¸è‰²ã§æç”»
      keySprite.beginFill(0xFF8C00); // ã‚ˆã‚Šé®®ã‚„ã‹ãªã‚ªãƒ¬ãƒ³ã‚¸è‰² (DarkOrange)
      keySprite.drawRect(-adjustedWidth * 0.75 / 2, 0, adjustedWidth * 0.75, blackKeyHeight);
      keySprite.endFill();
      
      // ä¸Šéƒ¨ã®ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœï¼ˆã‚ˆã‚Šæ˜ã‚‹ã„ã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
      keySprite.beginFill(0xFFB347, 0.9); // æ˜ã‚‹ã„ã‚ªãƒ¬ãƒ³ã‚¸
      keySprite.drawRect(-adjustedWidth * 0.75 / 2, 0, adjustedWidth * 0.75, blackKeyHeight * 0.3);
      keySprite.endFill();
      
      // ã‚¯ãƒªãƒƒã‚¯é ˜åŸŸï¼ˆãƒã‚¤ãƒ©ã‚¤ãƒˆæ™‚ã¯è–„ã„ã‚ªãƒ¬ãƒ³ã‚¸ï¼‰
      keySprite.beginFill(0xFF8C00, 0.3);
      keySprite.drawRect(-adjustedWidth / 2, 0, adjustedWidth, blackKeyHeight);
      keySprite.endFill();
    } else {
      // é»’éµã®å½±ï¼ˆèƒŒé¢ï¼‰
      keySprite.beginFill(0x000000, 0.3); // è–„ã„é»’ã®å½±
      keySprite.drawRect(-adjustedWidth * 0.75 / 2 + 1, 1, adjustedWidth * 0.75, blackKeyHeight);
      keySprite.endFill();
      
      // é€šå¸¸çŠ¶æ…‹ï¼šç´”ç²‹ãªé»’è‰²ã§æç”»
      keySprite.beginFill(this.settings.colors.blackKey); // ç´”ç²‹ãªé»’è‰²
      keySprite.drawRect(-adjustedWidth * 0.75 / 2, 0, adjustedWidth * 0.75, blackKeyHeight);
      keySprite.endFill();
      
      // é»’éµã®ä¸Šç«¯ãƒã‚¤ãƒ©ã‚¤ãƒˆï¼ˆå¾®å¦™ãªå…‰æ²¢åŠ¹æœï¼‰
      keySprite.beginFill(0x333333, 0.6); // è–„ã„ã‚°ãƒ¬ãƒ¼
      keySprite.drawRect(-adjustedWidth * 0.75 / 2, 0, adjustedWidth * 0.75, 2);
      keySprite.endFill();
      
      // ã‚¯ãƒªãƒƒã‚¯é ˜åŸŸï¼ˆé€æ˜ã€è¦–è¦šçš„ãªå½±éŸ¿ãªã—ï¼‰
      keySprite.beginFill(0x000000, 0.0); // å®Œå…¨é€æ˜
      keySprite.drawRect(-adjustedWidth / 2, 0, adjustedWidth, blackKeyHeight);
      keySprite.endFill();
    }
  }
  
  /**
   * ç™½éµã®ç·æ•°ã‚’è¨ˆç®—ï¼ˆãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ï¼‰
   */
  private calculateTotalWhiteKeys(): number {
    const minNote = 21;
    const maxNote = 108;
    let count = 0;
    for (let note = minNote; note <= maxNote; note++) {
      if (!this.isBlackKey(note)) {
        count++;
      }
    }
    return count;
  }
  
  /**
   * ãƒãƒ¼ãƒ„è¡¨ç¤ºã®æ›´æ–° - è¶…é«˜é€ŸåŒ–ç‰ˆ
   * é™ä¸‹è¨ˆç®—ã¯çŸ©å½¢ã‚ãŸã‚Š1è¡Œã€çµ¶å¯¾æ™‚åˆ»ã‹ã‚‰ç›´æ¥Yåº§æ¨™ã‚’è¨ˆç®—
   */
  updateNotes(activeNotes: ActiveNote[], currentTime?: number): void {
    if (!currentTime) return; // çµ¶å¯¾æ™‚åˆ»ãŒå¿…è¦
    
    const currentNoteIds = new Set(activeNotes.map(note => note.id));
    
    // GameEngineã¨åŒã˜è¨ˆç®—å¼ã‚’ä½¿ç”¨ï¼ˆçµ±ä¸€åŒ–ï¼‰
    const baseFallDuration = 5.0; // LOOKAHEAD_TIME
    const visualSpeedMultiplier = this.settings.noteSpeed;
    const totalDistance = this.settings.hitLineY - (-5); // ç”»é¢ä¸Šç«¯ã‹ã‚‰åˆ¤å®šãƒ©ã‚¤ãƒ³ã¾ã§
    const speedPxPerSec = (totalDistance / baseFallDuration) * visualSpeedMultiplier;
    
    // FPSç›£è¦–ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    this.fpsCounter++;
    if (currentTime - this.lastFpsTime >= 1000) {
      console.log(`ğŸš€ PIXI FPS: ${this.fpsCounter} | Notes: ${activeNotes.length} | Sprites: ${this.noteSprites.size} | hitLineY: ${this.settings.hitLineY} | speedPxPerSec: ${speedPxPerSec.toFixed(1)}`);
      this.fpsCounter = 0;
      this.lastFpsTime = currentTime;
    }
    
    // å¤ã„ãƒãƒ¼ãƒ„ã‚’å‰Šé™¤ï¼ˆé«˜é€Ÿãƒãƒƒãƒå‡¦ç†ï¼‰
    for (const [noteId] of this.noteSprites) {
      if (!currentNoteIds.has(noteId)) {
      this.removeNoteSprite(noteId);
      }
    }
    
    // ===== è¶…é«˜é€Ÿä½ç½®è¨ˆç®—ãƒ«ãƒ¼ãƒ— =====
    // åˆ†å²ãªã—ã€è¨ˆç®—ã®ã¿ã€1ãƒãƒ¼ãƒ„ã‚ãŸã‚Š1è¡Œã§å®Ÿè¡Œ
    for (const note of activeNotes) {
      let sprite = this.noteSprites.get(note.id);
      
      if (!sprite) {
        // æ–°è¦ãƒãƒ¼ãƒ„ä½œæˆï¼ˆçŠ¶æ…‹ç®¡ç†ã®ã¿ã€ä½ç½®ã¯å¾Œã§è¨­å®šï¼‰
        sprite = this.createNoteSprite(note);
      }
      
      // ===== æç”»ã‚³ã‚¹ãƒˆã‚¼ãƒ­ã®è¨ˆç®—ã®ã¿ =====
      // çµ¶å¯¾æ™‚åˆ»ã‹ã‚‰ç›´æ¥Yåº§æ¨™ã‚’è¨ˆç®—ï¼ˆGameEngineä¾å­˜ãªã—ï¼‰
      // Fix: currentTime is already in seconds, don't divide by 1000
      const newY = this.settings.hitLineY - (note.time - currentTime) * speedPxPerSec;
      sprite.sprite.y = newY;
      
      // è©³ç´°ä½ç½®ãƒ‡ãƒãƒƒã‚°ï¼ˆåˆå›ã®ã¿ï¼‰
      if (activeNotes.length > 0 && this.fpsCounter === 1) {
        console.log(`ğŸ¯ Position calculation: note.time=${note.time}, currentTime=${currentTime}, timeToHit=${note.time - currentTime}, newY=${newY}, hitLineY=${this.settings.hitLineY}, speedPxPerSec=${speedPxPerSec.toFixed(1)}`);
      }
      
      // ãƒ©ãƒ™ãƒ«ã¨ã‚°ãƒ­ãƒ¼ã‚‚åŒã˜Yåº§æ¨™ã«åŒæœŸ
      if (sprite.label) sprite.label.y = sprite.sprite.y - 8;
      if (sprite.glowSprite) sprite.glowSprite.y = sprite.sprite.y;
      
      // Xåº§æ¨™ã¯ãƒ”ãƒƒãƒå¤‰æ›´æ™‚ã®ã¿æ›´æ–°ï¼ˆé »åº¦ãŒä½ã„ï¼‰
      if (sprite.noteData.pitch !== note.pitch) {
        const x = this.pitchToX(note.pitch);
        sprite.sprite.x = x;
        if (sprite.label) sprite.label.x = x;
        if (sprite.glowSprite) sprite.glowSprite.x = x;
        }
      
      // çŠ¶æ…‹å¤‰æ›´ãƒã‚§ãƒƒã‚¯ï¼ˆé »åº¦ãŒä½ã„å‡¦ç†ã®ã¿ï¼‰
      if (sprite.noteData.state !== note.state) {
        this.updateNoteState(sprite, note);
      }
      
      sprite.noteData = note;
    }
  }
  
  private createNoteSprite(note: ActiveNote): NoteSprite {
    const effectivePitch = note.pitch + this.settings.transpose;
    const x = this.pitchToX(note.pitch);
    
    // ===== é©åˆ‡ãªãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’é¸æŠ =====
    const isBlackNote = this.isBlackKey(effectivePitch);
    const texture = isBlackNote ? this.noteTextures.blackVisible : this.noteTextures.whiteVisible;
    
    // ãƒ¡ã‚¤ãƒ³ãƒãƒ¼ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆä½ç½®ã¯å¾Œã§updateNotesã§è¨­å®šï¼‰
    const sprite = new PIXI.Sprite(texture);
    sprite.anchor.set(0.5, 0.5);
    sprite.x = x;
    sprite.y = 0; // å¾Œã§è¨­å®š
    
    console.log(`ğŸµ Creating main note sprite: texture=${texture.width}x${texture.height}, x=${x}, y=0, pitch=${effectivePitch}`);
    
    // éŸ³åãƒ©ãƒ™ãƒ«ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ã‹ã‚‰å–å¾—ã—ã¦ labelsContainer ã«é…ç½®ï¼‰
    let label: PIXI.Sprite | undefined;
    const _noteNameForLabel = this.getMidiNoteName(effectivePitch);
    if (_noteNameForLabel) {
      console.log(`ğŸ·ï¸ Creating label for note: ${_noteNameForLabel} (pitch: ${effectivePitch})`);
      
      try {
        const labelTexture = this.getLabelTexture(_noteNameForLabel);
        if (labelTexture) {
          label = new PIXI.Sprite(labelTexture);
          label.anchor.set(0.5, 1);
          label.x = x;
          label.y = 0; // å¾Œã§è¨­å®š
          
          // ParticleContainer ã¸ã®è¿½åŠ ã‚’è©¦è¡Œ
          try {
            this.labelsContainer.addChild(label);
            console.log(`âœ… Successfully added label sprite to container for "${_noteNameForLabel}"`);
          } catch (containerError) {
            console.error(`âŒ Failed to add label to ParticleContainer for "${_noteNameForLabel}":`, containerError);
            console.log(`ğŸ”„ Attempting fallback to regular container...`);
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å‡¦ç†ã‚’å®Ÿè¡Œ
            this.fallbackToRegularLabelContainer();
            
            // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯å¾Œã«å†è©¦è¡Œ
            try {
              this.labelsContainer.addChild(label);
              console.log(`âœ… Successfully added label to fallback container for "${_noteNameForLabel}"`);
            } catch (fallbackError) {
              console.error(`âŒ Even fallback container failed for "${_noteNameForLabel}":`, fallbackError);
              label.destroy();
              label = undefined;
            }
          }
        } else {
          console.warn(`âš ï¸ No texture available for label "${_noteNameForLabel}"`);
        }
      } catch (error) {
        console.error(`âŒ Error creating label sprite for "${_noteNameForLabel}":`, error);
        label = undefined;
      }
    } else {
      console.log(`ğŸ” No label name generated for pitch ${effectivePitch}`);
    }
    
    // ã‚°ãƒ­ãƒ¼åŠ¹æœã‚¹ãƒ—ãƒ©ã‚¤ãƒˆï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆOFFã€å¿…è¦æ™‚ã®ã¿ï¼‰
    let glowSprite: PIXI.Graphics | undefined;
    if (this.settings.effects.glow) {
      glowSprite = new PIXI.Graphics();
      glowSprite.x = x;
      glowSprite.y = 0; // å¾Œã§è¨­å®š
      this.effectsContainer.addChild(glowSprite);
    }
    
    try {
      this.notesContainer.addChild(sprite);
      console.log(`âœ… Successfully added main note sprite to notesContainer (pitch: ${effectivePitch})`);
    } catch (error) {
      console.error(`âŒ Failed to add main note sprite to notesContainer:`, error);
    }
    
    const noteSprite: NoteSprite = {
      sprite,
      glowSprite,
      noteData: note,
      label
    };
    
    this.noteSprites.set(note.id, noteSprite);
    return noteSprite;
  }
  
  /**
   * ãƒãƒ¼ãƒ„çŠ¶æ…‹å¤‰æ›´å‡¦ç†ï¼ˆé »åº¦ãŒä½ã„å‡¦ç†ã®ã¿ï¼‰
   */
  private updateNoteState(noteSprite: NoteSprite, note: ActiveNote): void {
    const effectivePitch = note.pitch + this.settings.transpose;

    // ==== åˆ¤å®šãƒ©ã‚¤ãƒ³é€šéæ™‚ã®ãƒ”ã‚¢ãƒã‚­ãƒ¼ç‚¹ç¯ ====
    if (note.crossingLogged && !noteSprite.noteData.crossingLogged && this.settings.practiceGuide !== 'off') {
      this.highlightKey(effectivePitch, true);
      setTimeout(() => this.highlightKey(effectivePitch, false), 150);
    }

    // ===== ãƒ†ã‚¯ã‚¹ãƒãƒ£äº¤æ›ã«ã‚ˆã‚‹çŠ¶æ…‹å¤‰æ›´ =====
    const isBlackNote = this.isBlackKey(effectivePitch);
    let newTexture: PIXI.Texture;
    
    switch (note.state) {
      case 'hit':
        newTexture = this.noteTextures.hit;
        break;
      case 'missed':
        // ãƒŸã‚¹æ™‚ã‚‚é€šå¸¸ã®è‰²ã‚’ç¶­æŒ
        newTexture = isBlackNote ? this.noteTextures.blackVisible : this.noteTextures.whiteVisible;
        break;
      case 'visible':
      default:
        newTexture = isBlackNote ? this.noteTextures.blackVisible : this.noteTextures.whiteVisible;
        break;
    }
    
    noteSprite.sprite.texture = newTexture;
    
    // ã‚°ãƒ­ãƒ¼åŠ¹æœã®æ›´æ–°
      if (noteSprite.glowSprite) {
        this.drawGlowShape(noteSprite.glowSprite, note.state, note.pitch);
      }
      
    // ãƒ©ãƒ™ãƒ«è¡¨ç¤º/éè¡¨ç¤ºåˆ¶å¾¡
    if (noteSprite.label) {
      noteSprite.label.visible = note.state !== 'hit';
      }
      
      // ãƒ’ãƒƒãƒˆæ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã¿ï¼ˆãƒŸã‚¹æ™‚ã¯ç„¡ã—ï¼‰
      if (note.state === 'hit') {
        const judgmentLabel = 'good';
        this.createHitEffect(noteSprite.sprite.x, noteSprite.sprite.y, note.state, judgmentLabel);
      }
  }
  
  private removeNoteSprite(noteId: string): void {
    const noteSprite = this.noteSprites.get(noteId);
    if (!noteSprite) return;
    
    // å®‰å…¨ãªå‰Šé™¤å‡¦ç†
    try {
      // ãƒ©ãƒ™ãƒ«ã‚’å…ˆã«å‰Šé™¤ï¼ˆlabelsContainer ã‹ã‚‰å‰Šé™¤ï¼‰
      if (noteSprite.label) {
        if (this.labelsContainer.children.includes(noteSprite.label)) {
          this.labelsContainer.removeChild(noteSprite.label);
        }
        noteSprite.label.destroy({ children: true, texture: false, baseTexture: false });
      }

      // ãƒ¡ã‚¤ãƒ³ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå‰Šé™¤
      if (noteSprite.sprite && noteSprite.sprite.parent) {
        noteSprite.sprite.parent.removeChild(noteSprite.sprite);
      }
      if (noteSprite.sprite && !noteSprite.sprite.destroyed) {
        noteSprite.sprite.destroy({ children: true, texture: false, baseTexture: false });
      }
      
      // ã‚°ãƒ­ãƒ¼ã‚¹ãƒ—ãƒ©ã‚¤ãƒˆå‰Šé™¤
      if (noteSprite.glowSprite) {
        if (noteSprite.glowSprite.parent) {
          noteSprite.glowSprite.parent.removeChild(noteSprite.glowSprite);
        }
        if (!noteSprite.glowSprite.destroyed) {
          noteSprite.glowSprite.destroy({ children: true, texture: false, baseTexture: false });
        }
      }
    } catch (error) {
      console.warn(`âš ï¸ Note sprite cleanup error for ${noteId}:`, error);
    }
    
    this.noteSprites.delete(noteId);
  }
  
  private drawGlowShape(graphics: PIXI.Graphics, state: ActiveNote['state'], pitch?: number): void {
    graphics.clear();
    
    // GOOD åˆ¤å®šå¾Œã®ãƒãƒ¼ãƒ„ã¯é€æ˜ã®ãŸã‚ã‚°ãƒ­ãƒ¼ã‚’æç”»ã—ãªã„
    if (state === 'hit') {
      return;
    }

    const color = this.getStateColor(state, pitch);
    const { noteWidth, noteHeight } = this.settings;
    
    // ã‚°ãƒ­ãƒ¼åŠ¹æœï¼ˆåŠé€æ˜ã®å¤§ããªçŸ©å½¢ï¼‰
    graphics.beginFill(color, 0.3);
    graphics.drawRoundedRect(
      -noteWidth / 2 - 4,
      -noteHeight / 2 - 4,
      noteWidth + 8,
      noteHeight + 8,
      6
    );
    graphics.endFill();
  }
  
  private createHitEffect(x: number, y: number, state: 'hit' | 'missed', judgment?: string): void {
    // ãƒ’ãƒƒãƒˆæ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã®ã¿ï¼ˆãƒŸã‚¹æ™‚ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯å‰Šé™¤ï¼‰
    const isGoodHit = state === 'hit' && judgment === 'good';
    
    if (isGoodHit) {
      // ã‚·ãƒ³ãƒ—ãƒ«ãªå††å½¢ã‚¨ãƒ•ã‚§ã‚¯ãƒˆ
      const effect = new PIXI.Graphics();
      effect.beginFill(this.settings.colors.good, 0.8);
      effect.drawCircle(0, 0, 16);
      effect.endFill();
      effect.x = x;
      effect.y = y;
      this.effectsContainer.addChild(effect);

      // çŸ­æ™‚é–“ã§æ¶ˆå»
      setTimeout(() => {
        try {
          if (effect && !effect.destroyed && this.effectsContainer.children.includes(effect)) {
            this.effectsContainer.removeChild(effect);
            effect.destroy();
          }
        } catch (err) {
          console.warn('ã‚¨ãƒ•ã‚§ã‚¯ãƒˆå‰Šé™¤ã‚¨ãƒ©ãƒ¼:', err);
        }
      }, 300);
    }
    
    // ãƒŸã‚¹æ™‚ã®ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯å‰Šé™¤
  }
  
  private getStateColor(state: ActiveNote['state'], pitch?: number): number {
    switch (state) {
      case 'visible': 
        if (pitch !== undefined && this.isBlackKey(pitch + this.settings.transpose)) {
          return this.settings.colors.visibleBlack;
        }
        return this.settings.colors.visible;
      case 'hit': return this.settings.colors.hit;
      case 'missed': return this.settings.colors.missed;
      default: return this.settings.colors.visible;
    }
  }
  
  private pitchToX(pitch: number): number {
    // 88éµãƒ”ã‚¢ãƒã®ãƒãƒƒãƒ”ãƒ³ã‚° (A0=21 to C8=108)
    const minNote = 21;
    const maxNote = 108;
    
    // ç™½éµã®ç·æ•°ã‚’è¨ˆç®—
    let totalWhiteKeys = 0;
    for (let note = minNote; note <= maxNote; note++) {
      if (!this.isBlackKey(note)) {
        totalWhiteKeys++;
      }
    }
    
    const effectivePitch = pitch + this.settings.transpose;

    if (this.isBlackKey(effectivePitch)) {
      // é»’éµã®å ´åˆã¯æ­£ç¢ºãªä½ç½®è¨ˆç®—ï¼ˆéš£æ¥ã™ã‚‹ç™½éµã®ä¸­å¤®ï¼‰
      return this.calculateBlackKeyPosition(effectivePitch, minNote, maxNote, totalWhiteKeys);
    } else {
      // ç™½éµã®å ´åˆ
      let whiteKeyIndex = 0;
      for (let note = minNote; note < effectivePitch; note++) {
        if (!this.isBlackKey(note)) {
          whiteKeyIndex++;
        }
      }
      const whiteKeyWidth = this.app.screen.width / totalWhiteKeys;
      return whiteKeyIndex * whiteKeyWidth + whiteKeyWidth / 2; // ç™½éµã®ä¸­å¤®
    }
  }
  
  private calculateNoteY(note: ActiveNote): number {
    // **GameEngineã‹ã‚‰è¨ˆç®—ã•ã‚ŒãŸç²¾å¯†ãªyåº§æ¨™ã‚’å„ªå…ˆä½¿ç”¨**
    if (note.y !== undefined) {
      return note.y;
    }
    
    // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç”»é¢å¤–ã«é…ç½®ï¼ˆé€šå¸¸ã¯ä½¿ç”¨ã•ã‚Œãªã„ï¼‰
    console.warn(`âš ï¸ ãƒãƒ¼ãƒ„Yåº§æ¨™ãŒGameEngineã‹ã‚‰æä¾›ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸ: ${note.id}`);
    return this.settings.hitLineY + 100;
  }
  
  /**
   * è¨­å®šæ›´æ–°
   */
  updateSettings(newSettings: Partial<RendererSettings>): void {
    console.log(`ğŸ”§ updateSettings called`);
    
    // ç ´æ£„å¾Œã«å‘¼ã°ã‚ŒãŸå ´åˆã®å®‰å…¨ã‚¬ãƒ¼ãƒ‰
    // this.app.renderer ã¯ destroy() å¾Œã«ãƒ—ãƒ­ãƒ‘ãƒ†ã‚£ãŒ undefined ã«ãªã‚‹ãŸã‚ãƒã‚§ãƒƒã‚¯
    if (!this.app || (this.app as any)._destroyed || !this.app.screen) {
      console.warn('PIXINotesRendererInstance.updateSettings: renderer already destroyed, skipping');
      return;
    }

    const prevPianoHeight = this.settings.pianoHeight;
    const prevTranspose = this.settings.transpose;
    const prevNoteNameStyle = this.settings.noteNameStyle;
    this.settings = { ...this.settings, ...newSettings };

    // ãƒ”ã‚¢ãƒé«˜ã•ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã€åˆ¤å®šãƒ©ã‚¤ãƒ³ã¨èƒŒæ™¯ã‚’å†é…ç½®
    if (newSettings.pianoHeight !== undefined && newSettings.pianoHeight !== prevPianoHeight) {
      // æ–°ã—ã„åˆ¤å®šãƒ©ã‚¤ãƒ³Yã‚’è¨ˆç®—
      // ä¿®æ­£: app.view.height ã‚’ä½¿ç”¨
      this.settings.hitLineY = this.app.view.height - this.settings.pianoHeight;
      console.log(`ğŸ”§ Updated hitLineY: ${this.settings.hitLineY}`);

      // æ—¢å­˜ã®ãƒ’ãƒƒãƒˆãƒ©ã‚¤ãƒ³ã‚’å‰Šé™¤ã—ã¦å†æç”»
      this.hitLineContainer.removeChildren();
      this.setupHitLine();

      // ==== èƒŒæ™¯ï¼ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’å†ç”Ÿæˆ ====
      try {
        // èƒŒæ™¯ (container ã®å…ˆé ­)
        if (this.container.children.length > 0) {
          this.container.removeChildAt(0);
        }

        // ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ (notesContainer ã®å…ˆé ­)
        if (this.notesContainer.children.length > 0) {
          const first = this.notesContainer.getChildAt(0);
          if (first) {
            this.notesContainer.removeChild(first);
          }
        }
      } catch (err) {
        console.warn('èƒŒæ™¯å†ç”Ÿæˆæ™‚ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', err);
      }

      // æ–°ã—ã„èƒŒæ™¯ã¨ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’å†ä½œæˆ
      this.createNotesAreaBackground();
    }

    // === noteNameStyle ãŒå¤‰åŒ–ã—ãŸå ´åˆã€éµç›¤ã¨ãƒãƒ¼ãƒˆã®éŸ³åè¡¨ç¤ºã‚’æ›´æ–° ===
    if (newSettings.noteNameStyle !== undefined && newSettings.noteNameStyle !== prevNoteNameStyle) {
      // éµç›¤ã®éŸ³åè¡¨ç¤ºã‚’æ›´æ–°ï¼ˆéµç›¤ã‚’å†æç”»ï¼‰
      this.pianoContainer.removeChildren();
      this.pianoSprites.clear();
      this.setupPiano();

      // æ—¢å­˜ãƒãƒ¼ãƒˆã®ãƒ©ãƒ™ãƒ«ã‚’æ›´æ–°
      this.noteSprites.forEach((noteSprite) => {
        const pitch = noteSprite.noteData.pitch;
        const effectivePitch = pitch + this.settings.transpose;
        const noteName = this.getMidiNoteName(effectivePitch);

        // å¤ã„ãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
        if (noteSprite.label) {
          if (this.labelsContainer.children.includes(noteSprite.label)) {
            this.labelsContainer.removeChild(noteSprite.label);
          }
          noteSprite.label.destroy();
          noteSprite.label = undefined;
        }

        // æ–°ã—ã„ãƒ©ãƒ™ãƒ«ã‚’ç”Ÿæˆï¼ˆnoteNameStyleãŒoffã§ãªã‘ã‚Œã°ï¼‰
        if (noteName) {
          const labelTexture = this.getLabelTexture(noteName);
          if (labelTexture) {
            const label = new PIXI.Sprite(labelTexture);
            label.anchor.set(0.5, 1);
            label.x = noteSprite.sprite.x;
            label.y = 0; // å¾Œã§è¨­å®š
            this.labelsContainer.addChild(label);
            noteSprite.label = label;
          }
        }
      });
    }

    // === transpose ãŒå¤‰åŒ–ã—ãŸå ´åˆã€æ—¢å­˜ãƒãƒ¼ãƒˆã®ãƒ©ãƒ™ãƒ« / ã‚«ãƒ©ãƒ¼ã‚’æ›´æ–° ===
    if (newSettings.transpose !== undefined && newSettings.transpose !== prevTranspose) {
      this.noteSprites.forEach((noteSprite) => {
        const pitch = noteSprite.noteData.pitch;
        const effectivePitch = pitch + this.settings.transpose;
        const noteName = this.getMidiNoteName(effectivePitch);

        // ãƒ©ãƒ™ãƒ«æ›´æ–°ï¼ˆãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚¢ãƒˆãƒ©ã‚¹ä½¿ç”¨ï¼‰
        if (noteSprite.label && noteName) {
          // æ—¢å­˜ãƒ©ãƒ™ãƒ«ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£ã‚’æ›´æ–°
          const newTexture = this.getLabelTexture(noteName);
          if (newTexture) {
            noteSprite.label.texture = newTexture;
          }
        } else if (!noteSprite.label && noteName) {
          // ãƒ©ãƒ™ãƒ«ãŒç„¡ã„å ´åˆã¯ç”Ÿæˆ
          const labelTexture = this.getLabelTexture(noteName);
          if (labelTexture) {
            const label = new PIXI.Sprite(labelTexture);
            label.anchor.set(0.5, 1);
            label.x = noteSprite.sprite.x;
            label.y = 0; // å¾Œã§è¨­å®š
            this.labelsContainer.addChild(label);
            noteSprite.label = label;
          }
        } else if (noteSprite.label && !noteName) {
          // è¡¨ç¤ºã‚¹ã‚¿ã‚¤ãƒ«ãŒ off ã®å ´åˆãƒ©ãƒ™ãƒ«ã‚’å‰Šé™¤
          if (this.labelsContainer.children.includes(noteSprite.label)) {
            this.labelsContainer.removeChild(noteSprite.label);
          }
          noteSprite.label.destroy();
          noteSprite.label = undefined;
        }

        // ã‚«ãƒ©ãƒ¼ãƒ»å½¢çŠ¶æ›´æ–°ï¼ˆSpriteç”¨ã®ãƒ†ã‚¯ã‚¹ãƒãƒ£äº¤æ›ï¼‰
        const noteData = noteSprite.noteData;
        const isBlackNote = this.isBlackKey(noteData.pitch + this.settings.transpose);
        let newTexture: PIXI.Texture;
        
        switch (noteData.state) {
          case 'hit':
            newTexture = this.noteTextures.hit;
            break;
          case 'missed':
            newTexture = this.noteTextures.missed;
            break;
          case 'visible':
          default:
            newTexture = isBlackNote ? this.noteTextures.blackVisible : this.noteTextures.whiteVisible;
            break;
        }
        
        noteSprite.sprite.texture = newTexture;
        
        if (noteSprite.glowSprite) {
          this.drawGlowShape(noteSprite.glowSprite, noteData.state, noteData.pitch);
        }
      });
    }
  }
  
  /**
   * ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
   */
  resize(width: number, height: number): void {
    this.app.renderer.resize(width, height);
    
    // ä¿®æ­£: app.view.height ã‚’ä½¿ç”¨
    this.settings.hitLineY = this.app.view.height - this.settings.pianoHeight;
    console.log(`ğŸ”§ Resize hitLineY: ${this.settings.hitLineY}`);
    
    // ãƒ”ã‚¢ãƒã¨ãƒ’ãƒƒãƒˆãƒ©ã‚¤ãƒ³ã®å†æç”»
    this.pianoContainer.removeChildren();
    this.pianoSprites.clear();
    this.hitLineContainer.removeChildren();
    
    this.setupPiano();
    this.setupHitLine();

    // ===== èƒŒæ™¯ã¨ã‚¬ã‚¤ãƒ‰ãƒ©ã‚¤ãƒ³ã‚’å†ç”Ÿæˆ =====
    try {
      if (this.container.children.length > 0) {
        this.container.removeChildAt(0);
      }
      if (this.notesContainer.children.length > 0) {
        const first = this.notesContainer.getChildAt(0);
        if (first) {
          this.notesContainer.removeChild(first);
        }
      }
    } catch (err) {
      console.warn('resize æ™‚ã®èƒŒæ™¯ã‚¯ãƒªã‚¢ã«å¤±æ•—', err);
    }

    this.createNotesAreaBackground();
  }
  
  /**
   * ãƒªã‚½ãƒ¼ã‚¹è§£æ”¾
   */
  destroy(): void {
    try {
      // ãƒãƒ¼ãƒˆã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’å®‰å…¨ã«å‰Šé™¤
      const noteIds = Array.from(this.noteSprites.keys());
      for (const noteId of noteIds) {
        this.removeNoteSprite(noteId);
      }
      this.noteSprites.clear();

      // ãƒ”ã‚¢ãƒã‚¹ãƒ—ãƒ©ã‚¤ãƒˆã‚’ã‚¯ãƒªã‚¢
      this.pianoSprites.clear();
      this.highlightedKeys.clear();

      // PIXI.jsã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚’ç ´æ£„
      if (this.app && (this.app as any)._destroyed !== true) {
        this.app.destroy(true, { 
          children: true, 
          texture: false,  // ãƒ†ã‚¯ã‚¹ãƒãƒ£ã¯å…±æœ‰ã•ã‚Œã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§false
          baseTexture: false 
        });
      }
    } catch (error) {
      console.warn('âš ï¸ PIXI renderer destroy error:', error);
    }
  }
  
  /**
   * ãƒ”ã‚¢ãƒã‚­ãƒ¼å…¥åŠ›ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯ã®è¨­å®š
   */
  setKeyCallbacks(onKeyPress: (note: number) => void, onKeyRelease: (note: number) => void): void {
    this.onKeyPress = onKeyPress;
    this.onKeyRelease = onKeyRelease;
  }

  /**
   * å†…éƒ¨ã‚­ãƒ¼ãƒ—ãƒ¬ã‚¹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
   */
  private handleKeyPress(midiNote: number): void {
    // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
    this.highlightKey(midiNote, true);
    
    // å¤–éƒ¨ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‘¼ã³å‡ºã—
    if (this.onKeyPress) {
      this.onKeyPress(midiNote);
    } else {
      console.warn(`âš ï¸ No onKeyPress callback set! Note: ${midiNote}`);
    }
  }
  
  /**
   * å†…éƒ¨ã‚­ãƒ¼ãƒªãƒªãƒ¼ã‚¹ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
   */
  private handleKeyRelease(midiNote: number): void {
    // é»’éµã¯å°‘ã—é•·ã‚ã«ãƒã‚¤ãƒ©ã‚¤ãƒˆã‚’ç¶­æŒ
    const isBlackKey = this.isBlackKey(midiNote);
    const highlightDuration = isBlackKey ? 200 : 150;
    
    setTimeout(() => {
      this.highlightKey(midiNote, false);
    }, highlightDuration);
    
    // å¤–éƒ¨ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯å‘¼ã³å‡ºã—
    if (this.onKeyRelease) {
      this.onKeyRelease(midiNote);
    } else {
      console.warn(`âš ï¸ No onKeyRelease callback set! Note: ${midiNote}`);
    }
  }

  /**
   * ã‚­ãƒ£ãƒ³ãƒã‚¹è¦ç´ ã®å–å¾—
   */
  get view(): HTMLCanvasElement {
    return this.app.view as HTMLCanvasElement;
  }

  // === ã‚°ãƒªãƒƒã‚µãƒ³ãƒ‰å‡¦ç† ===
  private handleDragStart(e: PIXI.FederatedPointerEvent): void {
    this.onDragActive = true;
    this.handleDragMove(e);
  }

  private handleDragMove(e: PIXI.FederatedPointerEvent): void {
    if (!this.onDragActive) return;
    const globalPos = e.data.global;
    const note = this.getNoteFromPosition(globalPos.x, globalPos.y);
    if (note !== null && note !== this.currentDragNote) {
      if (this.currentDragNote !== null) {
        // release previous
        this.handleKeyRelease(this.currentDragNote);
      }
      this.currentDragNote = note;
      this.handleKeyPress(note);
    }
  }

  private handleDragEnd(): void {
    if (this.currentDragNote !== null) {
      this.handleKeyRelease(this.currentDragNote);
      this.currentDragNote = null;
    }
    this.onDragActive = false;
  }

  /**
   * åº§æ¨™ã‹ã‚‰æœ€ã‚‚è¿‘ã„ MIDI ãƒãƒ¼ãƒˆç•ªå·ã‚’å–å¾—ã™ã‚‹ï¼ˆãƒ”ã‚¢ãƒã‚­ãƒ¼å†…ã®ã¿ï¼‰
   */
  private getNoteFromPosition(x: number, y: number): number | null {
    // hitLineY ä»¥é™ãŒéµç›¤ã‚¨ãƒªã‚¢
    if (y < this.settings.hitLineY) return null;
    for (const [midi, sprite] of this.pianoSprites) {
      const bounds = sprite.getBounds();
      if (x >= bounds.x && x <= bounds.x + bounds.width && y >= bounds.y && y <= bounds.y + bounds.height) {
        return midi;
      }
    }
    return null;
  }
}

// ===== React ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆ =====

export const PIXINotesRenderer: React.FC<PIXINotesRendererProps> = ({
  activeNotes,
  width,
  height,
  currentTime,
  onReady,
  className
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const rendererRef = useRef<PIXINotesRendererInstance | null>(null);
  
  // ===== PIXI.js ãƒ¬ãƒ³ãƒ€ãƒ©ãƒ¼åˆæœŸåŒ– (ä¸€åº¦ã ã‘) =====
  useEffect(() => {
    if (!containerRef.current || rendererRef.current) return;

    // åˆæœŸãƒ­ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°æ™‚ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã‚¤ãƒ³
    // ä¸€æ™‚çš„ã«ã‚³ãƒ¡ãƒ³ãƒˆã‚¢ã‚¦ãƒˆï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
    // containerRef.current.style.opacity = '0';
    // containerRef.current.style.visibility = 'hidden';
    
    console.log('ğŸ¯ Skipping initial hide for debugging...');

    const renderer = new PIXINotesRendererInstance(width, height);
    rendererRef.current = renderer;
    
    // ===== ç°¡ç•¥ãƒ‡ãƒãƒƒã‚°ï¼ˆãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹é‡è¦–ï¼‰ =====
    console.log('ğŸ” Basic check: Canvas size:', renderer.view.width, 'x', renderer.view.height);
    
    try {
      containerRef.current.appendChild(renderer.view);
      console.log('âœ… Canvas added to DOM');
    } catch (error) {
      console.error('âŒ appendChild failed:', error);
    }

    console.log('ğŸ¯ PIXI Container initially hidden, scheduling fade-in...');
    
    requestAnimationFrame(() => {
      console.log('ğŸ¯ Fade-in animation frame executing...');
      if (containerRef.current) {
        containerRef.current.style.opacity = '1';
        containerRef.current.style.visibility = 'visible';
        containerRef.current.style.transition = 'opacity 0.2s ease-in-out';
        console.log('âœ… PIXI Container made visible');
      } else {
        console.error('âŒ containerRef.current is null during fade-in');
      }
    });

    onReady?.(renderer);

    return () => {
      if (rendererRef.current) {
        rendererRef.current.destroy();
        rendererRef.current = null;
      }
      onReady?.(null);
    };
  }, []); // åˆå›ã®ã¿

  // onReady ãŒå¤‰æ›´ã•ã‚ŒãŸå ´åˆã«ã‚‚ç¾åœ¨ã® renderer ã‚’é€šçŸ¥
  useEffect(() => {
    if (rendererRef.current) {
      onReady?.(rendererRef.current);
    }
  }, [onReady]);
  
  // ãƒãƒ¼ãƒ„æ›´æ–°
  useEffect(() => {
    if (rendererRef.current) {
      rendererRef.current.updateNotes(activeNotes, currentTime);
    }
  }, [activeNotes, currentTime]);
  
  // ãƒªã‚µã‚¤ã‚ºå¯¾å¿œ
  useEffect(() => {
    if (rendererRef.current) {
      rendererRef.current.resize(width, height);
    }
  }, [width, height]);
  
  return (
    <div
      ref={containerRef}
      className={className}
      style={{ 
        width, 
        height,
        // åˆæœŸåŒ–æ™‚ã®ã‚µã‚¤ã‚ºå¤‰æ›´ã‚’é˜²ããŸã‚æ˜ç¤ºçš„ã«ã‚µã‚¤ã‚ºã‚’è¨­å®š
        minWidth: width,
        minHeight: height,
        overflow: 'hidden',
        backgroundColor: '#111827' // ãƒ­ãƒ¼ãƒ‰ä¸­ã®èƒŒæ™¯è‰²
      }}
    />
  );
};

export default PIXINotesRenderer; 