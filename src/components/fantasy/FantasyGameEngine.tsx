/**
 * „Éï„Ç°„É≥„Çø„Ç∏„Éº„Ç≤„Éº„É†„Ç®„É≥„Ç∏„É≥
 * „Ç≥„Éº„ÉâÂà§ÂÆö„Éª„Ç≤„Éº„É†„É≠„Ç∏„ÉÉ„ÇØ„ÇíÁÆ°ÁêÜ
 */

import { useState, useCallback, useEffect } from 'react';
import { devLog } from '@/utils/logger';
import { getMidiNoteName } from '@/utils/chordUtils';

// ===== ÂûãÂÆöÁæ© =====

interface ChordDefinition {
  id: string;           // "CM7"
  displayName: string;  // "CM7"
  notes: number[];      // [60, 64, 67, 71]
  noteNames: string[];  // ["„Éâ", "„Éü", "„ÇΩ", "„Ç∑"]
  quality: string;      // "M7"
  root: string;        // "C"
}

interface FantasyStage {
  id: string;
  stageNumber: string;
  name: string;
  description: string;
  maxHp: number;
  questionCount: number;
  enemyGaugeSeconds: number;
  mode: 'single' | 'progression';
  allowedChords: string[];
  chordProgression?: string[];
  showSheetMusic: boolean;
  showGuide: boolean; // „Ç¨„Ç§„ÉâË°®Á§∫Ë®≠ÂÆö„ÇíËøΩÂä†
  monsterIcon: string;
  bgmUrl?: string;
}

interface FantasyGameState {
  currentStage: FantasyStage | null;
  currentQuestionIndex: number;
  currentChordTarget: ChordDefinition | null;
  playerHp: number;
  enemyGauge: number;
  score: number;
  totalQuestions: number;
  correctAnswers: number;
  isGameActive: boolean;
  isGameOver: boolean;
  gameResult: 'clear' | 'gameover' | null;
  // Ë§áÊï∞Êïµ„Ç∑„Çπ„ÉÜ„É†Áî®
  currentEnemyIndex: number;
  currentEnemyHits: number;
  enemiesDefeated: number;
  totalEnemies: number;
  // Êïµ„ÅÆHPÁÆ°ÁêÜ„ÇíËøΩÂä†
  currentEnemyHp: number;
  maxEnemyHp: number;
}

interface FantasyGameEngineProps {
  stage: FantasyStage | null;
  onGameStateChange: (state: FantasyGameState) => void;
  onChordCorrect: (chord: ChordDefinition) => void;
  onChordIncorrect: (expectedChord: ChordDefinition, inputNotes: number[]) => void;
  onGameComplete: (result: 'clear' | 'gameover', finalState: FantasyGameState) => void;
  onEnemyAttack: () => void;
}

// ===== „Ç≥„Éº„ÉâÂÆöÁæ©„Éá„Éº„Çø =====

// „Éò„É´„Éë„ÉºÈñ¢Êï∞ÔºöMIDI„Éé„Éº„ÉàÈÖçÂàó„Åã„ÇâÈü≥ÂêçÈÖçÂàó„ÇíÁîüÊàê
const createNoteNames = (notes: number[]): string[] => {
  return notes.map(note => getMidiNoteName(note));
};

// „Éò„É´„Éë„ÉºÈñ¢Êï∞Ôºö„Ç≥„Éº„ÉâÂÆöÁæ©„Çí‰ΩúÊàê
const createChord = (id: string, displayName: string, notes: number[], quality: string, root: string): ChordDefinition => {
  return {
    id,
    displayName,
    notes,
    noteNames: createNoteNames(notes),
    quality,
    root
  };
};

const CHORD_DEFINITIONS: Record<string, ChordDefinition> = {
  // „É°„Ç∏„É£„Éº„Éà„É©„Ç§„Ç¢„Éâ
  'C': createChord('C', 'C', [60, 64, 67], 'major', 'C'),
  'F': createChord('F', 'F', [65, 69, 72], 'major', 'F'),
  'G': createChord('G', 'G', [67, 71, 74], 'major', 'G'),
  
  // „Éû„Ç§„Éä„Éº„Éà„É©„Ç§„Ç¢„Éâ
  'Am': createChord('Am', 'Am', [57, 60, 64], 'minor', 'A'),
  'Dm': createChord('Dm', 'Dm', [62, 65, 69], 'minor', 'D'),
  'Em': createChord('Em', 'Em', [64, 67, 71], 'minor', 'E'),
  
  // „Éâ„Éü„Éä„É≥„Éà7th
  'G7': createChord('G7', 'G7', [67, 71, 74, 77], 'dominant7', 'G'),
  'C7': createChord('C7', 'C7', [60, 64, 67, 70], 'dominant7', 'C'),
  'F7': createChord('F7', 'F7', [65, 69, 72, 75], 'dominant7', 'F'),
  
  // „Éû„Ç§„Éä„Éº7th
  'Am7': createChord('Am7', 'Am7', [57, 60, 64, 67], 'minor7', 'A'),
  'Dm7': createChord('Dm7', 'Dm7', [62, 65, 69, 72], 'minor7', 'D'),
  'Em7': createChord('Em7', 'Em7', [64, 67, 71, 74], 'minor7', 'E'),
  
  // „É°„Ç∏„É£„Éº7th
  'CM7': createChord('CM7', 'CM7', [60, 64, 67, 71], 'major7', 'C'),
  'FM7': createChord('FM7', 'FM7', [65, 69, 72, 76], 'major7', 'F'),
  'GM7': createChord('GM7', 'GM7', [67, 71, 74, 78], 'major7', 'G'),
  
  // „ÉÜ„É≥„Ç∑„Éß„É≥Á≥ª
  'C6': createChord('C6', 'C6', [60, 64, 67, 69], 'major6', 'C'),
  'Cm6': createChord('Cm6', 'Cm6', [60, 63, 67, 69], 'minor6', 'C'),
  'C9': createChord('C9', 'C9', [60, 64, 67, 70, 74], 'dominant9', 'C'),
  'Cm9': createChord('Cm9', 'Cm9', [60, 63, 67, 70, 74], 'minor9', 'C'),
  'C11': createChord('C11', 'C11', [60, 64, 67, 70, 74, 77], 'dominant11', 'C'),
  'C13': createChord('C13', 'C13', [60, 64, 67, 70, 74, 81], 'dominant13', 'C'),
  
  // ËøΩÂä†„ÅÆ„Éâ„Éü„Éä„É≥„Éà7th
  'B7': createChord('B7', 'B7', [71, 75, 78, 81], 'dominant7', 'B'),
  'E7': createChord('E7', 'E7', [64, 68, 71, 74], 'dominant7', 'E'),
  'A7': createChord('A7', 'A7', [69, 73, 76, 79], 'dominant7', 'A'),
  'D7': createChord('D7', 'D7', [62, 66, 69, 72], 'dominant7', 'D'),
  
  // === ÈªíÈçµ„É´„Éº„Éà„ÅÆ„Ç≥„Éº„Éâ („Ç∑„É£„Éº„ÉóÁ≥ª) ===
  // C#„É°„Ç∏„É£„ÉºÁ≥ª
  'C#': createChord('C#', 'C#', [61, 65, 68], 'major', 'C#'),
  'C#m': createChord('C#m', 'C#m', [61, 64, 68], 'minor', 'C#'),
  'C#7': createChord('C#7', 'C#7', [61, 65, 68, 71], 'dominant7', 'C#'),
  'C#m7': createChord('C#m7', 'C#m7', [61, 64, 68, 71], 'minor7', 'C#'),
  'C#M7': createChord('C#M7', 'C#M7', [61, 65, 68, 72], 'major7', 'C#'),
  
  // D#„É°„Ç∏„É£„ÉºÁ≥ª  
  'D#': createChord('D#', 'D#', [63, 67, 70], 'major', 'D#'),
  'D#m': createChord('D#m', 'D#m', [63, 66, 70], 'minor', 'D#'),
  'D#7': createChord('D#7', 'D#7', [63, 67, 70, 73], 'dominant7', 'D#'),
  'D#m7': createChord('D#m7', 'D#m7', [63, 66, 70, 73], 'minor7', 'D#'),
  
  // F#„É°„Ç∏„É£„ÉºÁ≥ª
  'F#': createChord('F#', 'F#', [66, 70, 73], 'major', 'F#'),
  'F#m': createChord('F#m', 'F#m', [66, 69, 73], 'minor', 'F#'),
  'F#7': createChord('F#7', 'F#7', [66, 70, 73, 76], 'dominant7', 'F#'),
  'F#m7': createChord('F#m7', 'F#m7', [66, 69, 73, 76], 'minor7', 'F#'),
  'F#M7': createChord('F#M7', 'F#M7', [66, 70, 73, 77], 'major7', 'F#'),
  
  // G#„É°„Ç∏„É£„ÉºÁ≥ª
  'G#': createChord('G#', 'G#', [68, 72, 75], 'major', 'G#'),
  'G#m': createChord('G#m', 'G#m', [68, 71, 75], 'minor', 'G#'),
  'G#7': createChord('G#7', 'G#7', [68, 72, 75, 78], 'dominant7', 'G#'),
  'G#m7': createChord('G#m7', 'G#m7', [68, 71, 75, 78], 'minor7', 'G#'),
  
  // A#„É°„Ç∏„É£„ÉºÁ≥ª
  'A#': createChord('A#', 'A#', [70, 74, 77], 'major', 'A#'),
  'A#m': createChord('A#m', 'A#m', [70, 73, 77], 'minor', 'A#'),
  'A#7': createChord('A#7', 'A#7', [70, 74, 77, 80], 'dominant7', 'A#'),
  'A#m7': createChord('A#m7', 'A#m7', [70, 73, 77, 80], 'minor7', 'A#'),
  
  // === ÈªíÈçµ„É´„Éº„Éà„ÅÆ„Ç≥„Éº„Éâ („Éï„É©„ÉÉ„ÉàÁ≥ª) ===
  // Db„É°„Ç∏„É£„ÉºÁ≥ª
  'Db': createChord('Db', 'Db', [61, 65, 68], 'major', 'Db'),
  'Dbm': createChord('Dbm', 'Dbm', [61, 64, 68], 'minor', 'Db'),
  'Db7': createChord('Db7', 'Db7', [61, 65, 68, 71], 'dominant7', 'Db'),
  'DbM7': createChord('DbM7', 'DbM7', [61, 65, 68, 72], 'major7', 'Db'),
  
  // Eb„É°„Ç∏„É£„ÉºÁ≥ª
  'Eb': createChord('Eb', 'Eb', [63, 67, 70], 'major', 'Eb'),
  'Ebm': createChord('Ebm', 'Ebm', [63, 66, 70], 'minor', 'Eb'),
  'Eb7': createChord('Eb7', 'Eb7', [63, 67, 70, 73], 'dominant7', 'Eb'),
  'EbM7': createChord('EbM7', 'EbM7', [63, 67, 70, 74], 'major7', 'Eb'),
  
  // Gb„É°„Ç∏„É£„ÉºÁ≥ª
  'Gb': createChord('Gb', 'Gb', [66, 70, 73], 'major', 'Gb'),
  'Gbm': createChord('Gbm', 'Gbm', [66, 69, 73], 'minor', 'Gb'),
  'Gb7': createChord('Gb7', 'Gb7', [66, 70, 73, 76], 'dominant7', 'Gb'),
  'GbM7': createChord('GbM7', 'GbM7', [66, 70, 73, 77], 'major7', 'Gb'),
  
  // Ab„É°„Ç∏„É£„ÉºÁ≥ª
  'Ab': createChord('Ab', 'Ab', [68, 72, 75], 'major', 'Ab'),
  'Abm': createChord('Abm', 'Abm', [68, 71, 75], 'minor', 'Ab'),
  'Ab7': createChord('Ab7', 'Ab7', [68, 72, 75, 78], 'dominant7', 'Ab'),
  'AbM7': createChord('AbM7', 'AbM7', [68, 72, 75, 79], 'major7', 'Ab'),
  
  // Bb„É°„Ç∏„É£„ÉºÁ≥ª
  'Bb': createChord('Bb', 'Bb', [70, 74, 77], 'major', 'Bb'),
  'Bbm': createChord('Bbm', 'Bbm', [70, 73, 77], 'minor', 'Bb'),
  'Bb7': createChord('Bb7', 'Bb7', [70, 74, 77, 80], 'dominant7', 'Bb'),
  'BbM7': createChord('BbM7', 'BbM7', [70, 74, 77, 81], 'major7', 'Bb')
};

// ===== Êïµ„É™„Çπ„ÉàÂÆöÁæ© =====

const ENEMY_LIST = [
  { id: 'vampire', icon: 'vampire', name: '„Éâ„É©„Ç≠„É•„É©' },
  { id: 'monster', icon: 'monster', name: 'ÊÄ™Áç£' },
  { id: 'reaper', icon: 'reaper', name: 'Ê≠ªÁ•û' },
  { id: 'kraken', icon: 'kraken', name: '„ÇØ„É©„Éº„Ç±„É≥' },
  { id: 'werewolf', icon: 'werewolf', name: 'ÁãºÁî∑' },
  { id: 'demon', icon: 'demon', name: 'È≠îÁéã' }
];

// ===== „Éò„É´„Éë„ÉºÈñ¢Êï∞ =====

/**
 * „Ç≥„Éº„ÉâÂà§ÂÆöÈñ¢Êï∞
 * ÊßãÊàêÈü≥„ÅåÂÖ®„Å¶Êäº„Åï„Çå„Å¶„ÅÑ„Çå„Å∞Ê≠£Ëß£ÔºàÈ†ÜÁï™„Éª„Ç™„ÇØ„Çø„Éº„Éñ‰∏çÂïè„ÄÅËª¢ÂõûÂΩ¢„ÇÇÊ≠£Ëß£„ÄÅ‰ΩôÂàÜ„Å™Èü≥„Åå„ÅÇ„Å£„Å¶„ÇÇÊßãÊàêÈü≥„ÅåÂê´„Åæ„Çå„Å¶„ÅÑ„Çå„Å∞Ê≠£Ëß£Ôºâ
 */
const checkChordMatch = (inputNotes: number[], targetChord: ChordDefinition): boolean => {
  if (inputNotes.length === 0) {
    devLog.debug('‚ùå „Ç≥„Éº„ÉâÂà§ÂÆö: ÂÖ•ÂäõÈü≥„Å™„Åó');
    return false;
  }
  
  // ÂÖ•Âäõ„Åï„Çå„ÅüÈü≥„Çí„Éé„Éº„ÉàÁï™Âè∑„ÅÆmod 12„ÅßÊ≠£Ë¶èÂåñÔºà„Ç™„ÇØ„Çø„Éº„ÉñÁÑ°Ë¶ñÔºâ
  const inputNotesMod12 = [...new Set(inputNotes.map(note => note % 12))]; // ÈáçË§áÈô§Âéª„ÇÇËøΩÂä†
  const targetNotesMod12 = [...new Set(targetChord.notes.map(note => note % 12))]; // ÈáçË§áÈô§Âéª„ÇÇËøΩÂä†
  
  // „Çø„Éº„Ç≤„ÉÉ„Éà„Ç≥„Éº„Éâ„ÅÆÂÖ®„Å¶„ÅÆÈü≥„ÅåÂÖ•Âäõ„Å´Âê´„Åæ„Çå„Å¶„ÅÑ„Çã„Åã„ÉÅ„Çß„ÉÉ„ÇØ
  const hasAllTargetNotes = targetNotesMod12.every(targetNote => 
    inputNotesMod12.includes(targetNote)
  );
  
  // „Çà„ÇäË©≥Á¥∞„Å™„É≠„Ç∞Âá∫Âäõ
  devLog.debug(`üéµ „Ç≥„Éº„ÉâÂà§ÂÆöË©≥Á¥∞:`, {
    targetChord: targetChord.displayName,
    targetNotes: targetChord.notes,
    targetMod12: targetNotesMod12,
    targetMod12Names: targetNotesMod12.map(note => {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      return noteNames[note];
    }),
    inputNotes: inputNotes,
    inputMod12: inputNotesMod12,
    inputMod12Names: inputNotesMod12.map(note => {
      const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
      return noteNames[note];
    }),
    hasAllTargetNotes,
    matchDetails: targetNotesMod12.map(targetNote => ({
      note: targetNote,
      noteName: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'][targetNote],
      found: inputNotesMod12.includes(targetNote)
    }))
  });
  
  return hasAllTargetNotes;
};

/**
 * „É©„É≥„ÉÄ„É†„Ç≥„Éº„ÉâÈÅ∏ÊäûÔºàallowedChords„Åã„ÇâÔºâ
 */
const selectRandomChord = (allowedChords: string[]): ChordDefinition | null => {
  const availableChords = allowedChords
    .map(chordId => CHORD_DEFINITIONS[chordId])
    .filter(Boolean);
    
  if (availableChords.length === 0) return null;
  
  const randomIndex = Math.floor(Math.random() * availableChords.length);
  return availableChords[randomIndex];
};

/**
 * „Ç≥„Éº„ÉâÈÄ≤Ë°å„Åã„ÇâÊ¨°„ÅÆ„Ç≥„Éº„Éâ„ÇíÂèñÂæó
 */
const getProgressionChord = (progression: string[], questionIndex: number): ChordDefinition | null => {
  if (progression.length === 0) return null;
  
  const chordId = progression[questionIndex % progression.length];
  return CHORD_DEFINITIONS[chordId] || null;
};

/**
 * ÁèæÂú®„ÅÆÊïµÊÉÖÂ†±„ÇíÂèñÂæó
 */
const getCurrentEnemy = (enemyIndex: number) => {
  if (enemyIndex >= 0 && enemyIndex < ENEMY_LIST.length) {
    return ENEMY_LIST[enemyIndex];
  }
  return ENEMY_LIST[0]; // „Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
};

// ===== „É°„Ç§„É≥„Ç≥„É≥„Éù„Éº„Éç„É≥„Éà =====

export const useFantasyGameEngine = ({
  stage,
  onGameStateChange,
  onChordCorrect,
  onChordIncorrect,
  onGameComplete,
  onEnemyAttack
}: FantasyGameEngineProps) => {
  
  const [gameState, setGameState] = useState<FantasyGameState>({
    currentStage: null,
    currentQuestionIndex: 0,
    currentChordTarget: null,
    playerHp: 5,
    enemyGauge: 0,
    score: 0,
    totalQuestions: 0,
    correctAnswers: 0,
    isGameActive: false,
    isGameOver: false,
    gameResult: null,
    // Ë§áÊï∞Êïµ„Ç∑„Çπ„ÉÜ„É†Áî®
    currentEnemyIndex: 0,
    currentEnemyHits: 0,
    enemiesDefeated: 0,
    totalEnemies: 5,
    // Êïµ„ÅÆHPÁÆ°ÁêÜ„ÇíËøΩÂä†
    currentEnemyHp: 5,
    maxEnemyHp: 5
  });
  
  const [enemyGaugeTimer, setEnemyGaugeTimer] = useState<NodeJS.Timeout | null>(null);
  const [inputBuffer, setInputBuffer] = useState<number[]>([]);
  const [inputTimeout, setInputTimeout] = useState<NodeJS.Timeout | null>(null);
  
  // „Ç≤„Éº„É†ÂàùÊúüÂåñ
  const initializeGame = useCallback(() => {
    devLog.debug('üéÆ „Ç≤„Éº„É†ÂàùÊúüÂåñÈñãÂßã:', stage);
    
    if (!stage) {
      devLog.debug('‚ùå „Çπ„ÉÜ„Éº„Ç∏ÊÉÖÂ†±„Åå„ÅÇ„Çä„Åæ„Åõ„Çì');
      return;
    }
    
    const firstChord = stage.mode === 'single' 
      ? selectRandomChord(stage.allowedChords)
      : getProgressionChord(stage.chordProgression || [], 0);
    
    devLog.debug('üéØ ÊúÄÂàù„ÅÆ„Ç≥„Éº„ÉâÈÅ∏Êäû:', {
      mode: stage.mode,
      allowedChords: stage.allowedChords,
      chordProgression: stage.chordProgression,
      selectedChord: firstChord
    });
    
    if (!firstChord) {
      devLog.debug('‚ùå ÊúÄÂàù„ÅÆ„Ç≥„Éº„Éâ„ÇíÈÅ∏Êäû„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü');
      return;
    }
    
    const newState: FantasyGameState = {
      currentStage: stage,
      currentQuestionIndex: 0,
      currentChordTarget: firstChord,
      playerHp: stage.maxHp,
      enemyGauge: 0,
      score: 0,
      totalQuestions: stage.questionCount,
      correctAnswers: 0,
      isGameActive: true,
      isGameOver: false,
      gameResult: null,
      // Ë§áÊï∞Êïµ„Ç∑„Çπ„ÉÜ„É†Áî®
      currentEnemyIndex: 0,
      currentEnemyHits: 0,
      enemiesDefeated: 0,
      totalEnemies: 5,
      // Êïµ„ÅÆHPÁÆ°ÁêÜ„ÇíËøΩÂä†
      currentEnemyHp: 5,
      maxEnemyHp: 5
    };
    
    setGameState(newState);
    setInputBuffer([]);
    onGameStateChange(newState);
    
    devLog.debug('‚úÖ „Éï„Ç°„É≥„Çø„Ç∏„Éº„Ç≤„Éº„É†ÂàùÊúüÂåñÂÆå‰∫Ü:', newState);
  }, [stage, onGameStateChange]);
  
  // Ê¨°„ÅÆÂïèÈ°å„Å∏„ÅÆÁßªË°åÔºàÂõûÁ≠îÊï∞„Éô„Éº„Çπ„ÄÅ„É´„Éº„ÉóÂØæÂøúÔºâ
  const proceedToNextQuestion = useCallback(() => {
    setGameState(prevState => {
      const nextCorrectAnswers = prevState.correctAnswers;
      const isComplete = nextCorrectAnswers >= prevState.totalQuestions; // ÂõûÁ≠îÊï∞„Åß„ÇØ„É™„Ç¢Âà§ÂÆö
      
      if (isComplete) {
        // „Ç≤„Éº„É†„ÇØ„É™„Ç¢
        const finalState = {
          ...prevState,
          isGameActive: false,
          isGameOver: true,
          gameResult: 'clear' as const
        };
        
        onGameComplete('clear', finalState);
        return finalState;
      } else {
        // Ê¨°„ÅÆÂïèÈ°åÔºà„É´„Éº„ÉóÂØæÂøúÔºâ
        let nextChord;
        if (prevState.currentStage?.mode === 'single') {
          // „É©„É≥„ÉÄ„É†„É¢„Éº„ÉâÔºö„Åù„ÅÆ„Åæ„Åæ
          nextChord = selectRandomChord(prevState.currentStage.allowedChords);
        } else {
          // „Ç≥„Éº„ÉâÈÄ≤Ë°å„É¢„Éº„ÉâÔºö„É´„Éº„Éó„Åï„Åõ„Çã
          const progression = prevState.currentStage?.chordProgression || [];
          const nextIndex = (prevState.currentQuestionIndex + 1) % progression.length;
          nextChord = getProgressionChord(progression, nextIndex);
        }
        
        const nextState = {
          ...prevState,
          currentQuestionIndex: (prevState.currentQuestionIndex + 1) % (prevState.currentStage?.chordProgression?.length || 1),
          currentChordTarget: nextChord,
          enemyGauge: 0 // „Ç≤„Éº„Ç∏„É™„Çª„ÉÉ„Éà
        };
        
        onGameStateChange(nextState);
        return nextState;
      }
    });
  }, [onGameStateChange, onGameComplete]);
  
  // Êïµ„ÅÆÊîªÊíÉÂá¶ÁêÜ
  const handleEnemyAttack = useCallback(() => {
    // ÊîªÊíÉÊôÇ„Å´ÂÖ•Âäõ„Éê„ÉÉ„Éï„Ç°„Çí„É™„Çª„ÉÉ„Éà
    setInputBuffer([]);
    if (inputTimeout) {
      clearTimeout(inputTimeout);
      setInputTimeout(null);
    }
    
    setGameState(prevState => {
      const newHp = Math.max(0, prevState.playerHp - 1); // Á¢∫ÂÆü„Å´1Ê∏õ„Çâ„Åô
      
      devLog.debug('üí• Êïµ„ÅÆÊîªÊíÉÔºÅHPÊõ¥Êñ∞:', {
        oldHp: prevState.playerHp,
        newHp: newHp,
        damage: 1
      });
      
      const isGameOver = newHp <= 0;
      
      if (isGameOver) {
        const finalState = {
          ...prevState,
          playerHp: 0,
          isGameActive: false,
          isGameOver: true,
          gameResult: 'gameover' as const
        };
        
        // „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆâÂÖ®„Å´Âëº„Å≥Âá∫„Åó
        setTimeout(() => {
          try {
            onGameComplete('gameover', finalState);
          } catch (error) {
            devLog.debug('‚ùå „Ç≤„Éº„É†„Ç™„Éº„Éê„Éº„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
          }
        }, 100);
        
        return finalState;
      } else {
        // HPÊ∏õÂ∞ë„Åó„Å¶Ê¨°„ÅÆÂïèÈ°å„Å∏ÔºàÂõûÁ≠îÊï∞„Éô„Éº„Çπ„ÄÅ„É´„Éº„ÉóÂØæÂøúÔºâ
        const isComplete = prevState.correctAnswers >= prevState.totalQuestions;
        
        if (isComplete) {
          // ÂøÖË¶Å„Å™ÂõûÁ≠îÊï∞„Å´Âà∞ÈÅîÊ∏à„Åø„ÅßHPÊÆã„Çä„ÅÇ„Çä„Å™„Çâ„ÇØ„É™„Ç¢
          const finalState = {
            ...prevState,
            playerHp: newHp,
            isGameActive: false,
            isGameOver: true,
            gameResult: 'clear' as const
          };
          
          // „ÇØ„É™„Ç¢„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆâÂÖ®„Å´Âëº„Å≥Âá∫„Åó
          setTimeout(() => {
            try {
              onGameComplete('clear', finalState);
            } catch (error) {
              devLog.debug('‚ùå „ÇØ„É™„Ç¢„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
            }
          }, 100);
          
          return finalState;
        } else {
          // Ê¨°„ÅÆÂïèÈ°åÔºà„É´„Éº„ÉóÂØæÂøúÔºâ
          let nextChord;
          if (prevState.currentStage?.mode === 'single') {
            // „É©„É≥„ÉÄ„É†„É¢„Éº„ÉâÔºö„Åù„ÅÆ„Åæ„Åæ
            nextChord = selectRandomChord(prevState.currentStage.allowedChords);
          } else {
            // „Ç≥„Éº„ÉâÈÄ≤Ë°å„É¢„Éº„ÉâÔºö„É´„Éº„Éó„Åï„Åõ„Çã
            const progression = prevState.currentStage?.chordProgression || [];
            const nextIndex = (prevState.currentQuestionIndex + 1) % progression.length;
            nextChord = getProgressionChord(progression, nextIndex);
          }
          
          const nextState = {
            ...prevState,
            playerHp: newHp,
            currentQuestionIndex: (prevState.currentQuestionIndex + 1) % (prevState.currentStage?.chordProgression?.length || 1),
            currentChordTarget: nextChord,
            enemyGauge: 0
          };
          
          onGameStateChange(nextState);
          return nextState;
        }
      }
    });
    
    onEnemyAttack();
  }, [onGameStateChange, onGameComplete, onEnemyAttack, inputTimeout]);
  
  // „Ç≤„Éº„Ç∏„Çø„Ç§„Éû„Éº„ÅÆÁÆ°ÁêÜ
  useEffect(() => {
    devLog.debug('üéÆ „Ç≤„Éº„Ç∏„Çø„Ç§„Éû„ÉºÁä∂ÊÖã„ÉÅ„Çß„ÉÉ„ÇØ:', { 
      isGameActive: gameState.isGameActive, 
      hasTimer: !!enemyGaugeTimer,
      currentStage: gameState.currentStage?.stageNumber
    });
    
    // Êó¢Â≠ò„ÅÆ„Çø„Ç§„Éû„Éº„Çí„ÇØ„É™„Ç¢
    if (enemyGaugeTimer) {
      clearInterval(enemyGaugeTimer);
      setEnemyGaugeTimer(null);
    }
    
    // „Ç≤„Éº„É†„Åå„Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Å™Â†¥Âêà„ÅÆ„ÅøÊñ∞„Åó„ÅÑ„Çø„Ç§„Éû„Éº„ÇíÈñãÂßã
    if (gameState.isGameActive && gameState.currentStage) {
      devLog.debug('‚è∞ Êïµ„Ç≤„Éº„Ç∏„Çø„Ç§„Éû„ÉºÈñãÂßã');
      const timer = setInterval(() => {
        updateEnemyGauge();
      }, 100); // 100msÈñìÈöî„ÅßÊõ¥Êñ∞
      setEnemyGaugeTimer(timer);
    }
    
    // „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
    return () => {
      if (enemyGaugeTimer) {
        clearInterval(enemyGaugeTimer);
      }
    };
  }, [gameState.isGameActive, gameState.currentStage]); // „Ç≤„Éº„É†Áä∂ÊÖã„Å®„Çπ„ÉÜ„Éº„Ç∏„ÅÆÂ§âÊõ¥„ÇíÁõ£Ë¶ñ
  
  // Êïµ„Ç≤„Éº„Ç∏„ÅÆÊõ¥Êñ∞
  const updateEnemyGauge = useCallback(() => {
    setGameState(prevState => {
      if (!prevState.isGameActive || !prevState.currentStage) {
        devLog.debug('‚è∞ „Ç≤„Éº„Ç∏Êõ¥Êñ∞„Çπ„Ç≠„ÉÉ„Éó: „Ç≤„Éº„É†Èùû„Ç¢„ÇØ„ÉÜ„Ç£„Éñ');
        return prevState;
      }
      
      const incrementRate = 100 / (prevState.currentStage.enemyGaugeSeconds * 10); // 100msÈñìÈöî„ÅßÊõ¥Êñ∞
      const newGauge = prevState.enemyGauge + incrementRate;
      
      devLog.debug('‚ö° „Ç≤„Éº„Ç∏Êõ¥Êñ∞:', { 
        currentGauge: prevState.enemyGauge.toFixed(1), 
        newGauge: newGauge.toFixed(1), 
        incrementRate: incrementRate.toFixed(2),
        enemyGaugeSeconds: prevState.currentStage.enemyGaugeSeconds
      });
      
      if (newGauge >= 100) {
        // „Ç≤„Éº„Ç∏Ê∫Ä„Çø„É≥ -> Êïµ„ÅÆÊîªÊíÉ
        devLog.debug('üí• Êïµ„Ç≤„Éº„Ç∏Ê∫Ä„Çø„É≥ÔºÅÊîªÊíÉÈñãÂßã');
        // ÊîªÊíÉÂá¶ÁêÜ„ÇíÈùûÂêåÊúü„ÅßÂÆüË°å„Åó„ÄÅ„Åì„Åì„Åß„ÅØ„Ç≤„Éº„Ç∏„Çí„É™„Çª„ÉÉ„Éà
        setTimeout(() => handleEnemyAttack(), 0);
        const nextState = { ...prevState, enemyGauge: 0 }; // „Ç≤„Éº„Ç∏„Çí„É™„Çª„ÉÉ„Éà
        onGameStateChange(nextState);
        return nextState;
      } else {
        const nextState = { ...prevState, enemyGauge: newGauge };
        onGameStateChange(nextState);
        return nextState;
      }
    });
  }, [handleEnemyAttack, onGameStateChange]);
  
  // „Éé„Éº„ÉàÂÖ•ÂäõÂá¶ÁêÜ
  const handleNoteInput = useCallback((note: number) => {
    if (!gameState.isGameActive || !gameState.currentChordTarget) return;
    
    devLog.debug('üéµ „Éé„Éº„ÉàÂÖ•ÂäõÂèó‰ø°:', { note, currentChord: gameState.currentChordTarget.displayName });
    
    // ÂÖ•Âäõ„Éê„ÉÉ„Éï„Ç°„Å´ËøΩÂä†
    setInputBuffer(prevBuffer => {
      const newBuffer = [...prevBuffer, note];
      devLog.debug('üéµ ÂÖ•Âäõ„Éê„ÉÉ„Éï„Ç°Êõ¥Êñ∞:', { newBuffer, bufferSize: newBuffer.length });
      
      // ÂÖ•Âäõ„Çø„Ç§„É†„Ç¢„Ç¶„Éà„Çí„É™„Çª„ÉÉ„Éà
      if (inputTimeout) {
        clearTimeout(inputTimeout);
      }
      
      // Ëá™ÂãïÂà§ÂÆö„Çø„Ç§„Éû„ÉºÔºà500ms„Å´Âª∂Èï∑ - ÂíåÈü≥„ÅåÂÆåÊàê„Åô„Çã„Åæ„ÅßÂæÖÊ©üÔºâ
      const timeout = setTimeout(() => {
        devLog.debug('‚è∞ Ëá™ÂãïÂà§ÂÆö„Çø„Ç§„Éû„ÉºÁô∫Âãï');
        checkCurrentInput(newBuffer);
        // Ê≠£Ëß£„ÅÆÂ†¥Âêà„ÅÆ„Åø„Éê„ÉÉ„Éï„Ç°„Çí„ÇØ„É™„Ç¢ÔºàcheckCurrentInputÂÜÖ„ÅßÂá¶ÁêÜÔºâ
      }, 500);
      
      setInputTimeout(timeout);
      
      // Âç≥Â∫ß„Å´Âà§ÂÆö„ÇÇË©¶Ë°åÔºàÊßãÊàêÈü≥Êï∞„ÅåÊ∫Ä„Åü„Åï„Çå„ÅüÂ†¥ÂêàÔºâ
      if (gameState.currentChordTarget && newBuffer.length >= gameState.currentChordTarget.notes.length) {
        devLog.debug('üéØ ÊßãÊàêÈü≥Êï∞ÈÅîÊàê - Âç≥Â∫ß„Å´Âà§ÂÆö');
        setTimeout(() => {
          clearTimeout(timeout);
          const isCorrectImmediate = checkChordMatch(newBuffer, gameState.currentChordTarget!);
          if (isCorrectImmediate) {
            checkCurrentInput(newBuffer);
            setInputBuffer([]);
          }
          // ‰∏çÊ≠£Ëß£„ÅÆÂ†¥Âêà„ÅØ‰Ωï„ÇÇ„Åõ„Åö„ÄÅÈü≥„ÅÆÁ©ç„ÅøÈáç„Å≠„ÇíÁ∂ôÁ∂ö
        }, 100);
      }
      
      return newBuffer;
    });
  }, [gameState.isGameActive, gameState.currentChordTarget, inputTimeout]);
  
  // ÁèæÂú®„ÅÆÂÖ•Âäõ„ÇíÂà§ÂÆö
  const checkCurrentInput = useCallback((notes: number[]) => {
    if (!gameState.currentChordTarget || notes.length === 0) {
      devLog.debug('‚ùå Âà§ÂÆö„Çπ„Ç≠„ÉÉ„Éó: „Ç≥„Éº„Éâ„Å™„Åó„Åæ„Åü„ÅØÂÖ•Âäõ„Å™„Åó', { hasChord: !!gameState.currentChordTarget, inputCount: notes.length });
      return;
    }
    
    devLog.debug('üéØ „Ç≥„Éº„ÉâÂà§ÂÆöÂÆüË°å‰∏≠...', { 
      targetChord: gameState.currentChordTarget.displayName,
      inputNotes: notes,
      inputCount: notes.length 
    });
    
    const isCorrect = checkChordMatch(notes, gameState.currentChordTarget);
    
    if (isCorrect) {
      devLog.debug('‚úÖ Ê≠£Ëß£Âà§ÂÆö!', { chord: gameState.currentChordTarget.displayName });
      
      // Ê≠£Ëß£
      onChordCorrect(gameState.currentChordTarget);
      
      setGameState(prevState => {
        const newHits = prevState.currentEnemyHits + 1;
        const newEnemyHp = Math.max(0, prevState.currentEnemyHp - 1); // Êïµ„ÅÆHP„Çí1Ê∏õ„Çâ„Åô
        
        let nextState = {
          ...prevState,
          correctAnswers: prevState.correctAnswers + 1,
          score: prevState.score + 1000,
          enemyGauge: 0, // „Ç≤„Éº„Ç∏„Çí„É™„Çª„ÉÉ„Éà
          currentEnemyHits: newHits,
          currentEnemyHp: newEnemyHp
        };
        
        devLog.debug('‚öîÔ∏è Êïµ„Å´„ÉÄ„É°„Éº„Ç∏:', {
          oldHp: prevState.currentEnemyHp,
          newHp: newEnemyHp,
          hits: newHits
        });
        
        // Êïµ„ÇíÂÄí„Åó„Åü„ÅãÂà§ÂÆöÔºàHP„Åå0„Å´„Å™„Å£„Åü„ÇâÂÄí„Çå„ÇãÔºâ
        if (newEnemyHp <= 0) {
          const newEnemiesDefeated = prevState.enemiesDefeated + 1;
          const nextEnemyIndex = prevState.currentEnemyIndex + 1;
          
          // ÂÖ®„Å¶„ÅÆÊïµ„ÇíÂÄí„Åó„Åü„Åã„ÉÅ„Çß„ÉÉ„ÇØ
          if (newEnemiesDefeated >= prevState.totalEnemies) {
            // „Ç≤„Éº„É†„ÇØ„É™„Ç¢
            nextState = {
              ...nextState,
              enemiesDefeated: newEnemiesDefeated,
              isGameActive: false,
              isGameOver: true,
              gameResult: 'clear'
            };
            
            devLog.debug('üéâ ÂÖ®„Å¶„ÅÆÊïµ„ÇíÂÄí„Åó„Å¶„Ç≤„Éº„É†„ÇØ„É™„Ç¢!', { enemiesDefeated: newEnemiesDefeated });
            
            // „Ç≤„Éº„É†ÂÆå‰∫Ü„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„ÇíÂÆâÂÖ®„Å´Âëº„Å≥Âá∫„Åó
            setTimeout(() => {
              try {
                onGameComplete('clear', nextState);
              } catch (error) {
                devLog.debug('‚ùå „Ç≤„Éº„É†ÂÆå‰∫Ü„Ç≥„Éº„É´„Éê„ÉÉ„ÇØ„Ç®„É©„Éº:', error);
              }
            }, 200);
          } else {
            // Ê¨°„ÅÆÊïµ„Å´‰∫§‰ª£
            nextState = {
              ...nextState,
              currentEnemyIndex: nextEnemyIndex,
              currentEnemyHits: 0,
              enemiesDefeated: newEnemiesDefeated,
              currentEnemyHp: prevState.maxEnemyHp, // Êñ∞„Åó„ÅÑÊïµ„ÅÆHP„Çí„Éï„É´ÂõûÂæ©
            };
            
            devLog.debug('üëπ Êïµ„ÇíÂÄí„Åó„ÅüÔºÅÊ¨°„ÅÆÊïµ„ÅåÂá∫Áèæ:', { 
              defeatedEnemies: newEnemiesDefeated,
              nextEnemyIndex,
              nextEnemy: ENEMY_LIST[nextEnemyIndex]?.name,
              newEnemyHp: prevState.maxEnemyHp
            });
          }
        }
        
        onGameStateChange(nextState);
        return nextState;
      });
      
      // ÂÖ•Âäõ„Éê„ÉÉ„Éï„Ç°„Çí„ÇØ„É™„Ç¢
      setInputBuffer([]);
      
      // Ê¨°„ÅÆÂïèÈ°å„Å∏ÔºàÂæÖÊ©üÊôÇÈñì„Çí 0 „Å´Â§âÊõ¥Ôºâ
      setTimeout(proceedToNextQuestion, 0);
      
    } else {
      devLog.debug('üéµ „Åæ„Å†ÊßãÊàêÈü≥„ÅåË∂≥„Çä„Åæ„Åõ„Çì', { 
        targetChord: gameState.currentChordTarget.displayName,
        inputNotes: notes,
        message: 'Èü≥„ÇíËøΩÂä†„Åó„Å¶„Åè„Å†„Åï„ÅÑ'
      });
      
      // ‰∏çÊ≠£Ëß£„ÅÆÊ¶ÇÂøµ„ÇíÂâäÈô§„Åó„ÄÅÂçòÁ¥î„Å´‰Ωï„ÇÇ„Åó„Å™„ÅÑÔºàÈü≥„ÅÆÁ©ç„ÅøÈáç„Å≠„ÇíÁ∂öË°åÔºâ
      // onChordIncorrect(gameState.currentChordTarget, notes);
    }
  }, [gameState.currentChordTarget, onChordCorrect, onChordIncorrect, onGameStateChange, proceedToNextQuestion]);
  
  // ÊâãÂãï„ÅßÁèæÂú®„ÅÆÂÖ•Âäõ„ÇíÂà§ÂÆöÔºàÂâäÈô§‰∫àÂÆö - Ëá™ÂãïÂà§ÂÆö„ÅÆ„Åø‰ΩøÁî®Ôºâ
  // const submitCurrentInput = useCallback(() => {
  //   if (inputTimeout) {
  //     clearTimeout(inputTimeout);
  //     setInputTimeout(null);
  //   }
  //   
  //   checkCurrentInput(inputBuffer);
  //   setInputBuffer([]);
  // }, [inputTimeout, checkCurrentInput, inputBuffer]);
  
  // „Ç≤„Éº„É†ÂÅúÊ≠¢
  const stopGame = useCallback(() => {
    setGameState(prevState => ({
      ...prevState,
      isGameActive: false
    }));
    
    if (enemyGaugeTimer) {
      clearInterval(enemyGaugeTimer);
      setEnemyGaugeTimer(null);
    }
    
    if (inputTimeout) {
      clearTimeout(inputTimeout);
      setInputTimeout(null);
    }
    
    setInputBuffer([]);
  }, [enemyGaugeTimer, inputTimeout]);
  
  // „Çπ„ÉÜ„Éº„Ç∏Â§âÊõ¥ÊôÇ„ÅÆÂàùÊúüÂåñ
  useEffect(() => {
    if (stage) {
      initializeGame();
    }
  }, [stage, initializeGame]);
  
  // „Ç≥„É≥„Éù„Éº„Éç„É≥„ÉàÁ†¥Ê£ÑÊôÇ„ÅÆ„ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó
  useEffect(() => {
    return () => {
      if (enemyGaugeTimer) {
        devLog.debug('‚è∞ Êïµ„Ç≤„Éº„Ç∏„Çø„Ç§„Éû„Éº „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÅßÂÅúÊ≠¢');
        clearInterval(enemyGaugeTimer);
      }
      if (inputTimeout) {
        devLog.debug('‚è∞ ÂÖ•Âäõ„Çø„Ç§„É†„Ç¢„Ç¶„Éà „ÇØ„É™„Éº„É≥„Ç¢„ÉÉ„Éó„ÅßÂÅúÊ≠¢');
        clearTimeout(inputTimeout);
      }
    };
  }, []);
  
  return {
    gameState,
    inputBuffer,
    handleNoteInput,
    initializeGame,
    stopGame,
    
    // „Éò„É´„Éë„ÉºÈñ¢Êï∞„ÇÇ„Ç®„ÇØ„Çπ„Éù„Éº„Éà
    checkChordMatch,
    selectRandomChord,
    getProgressionChord,
    getCurrentEnemy,
    CHORD_DEFINITIONS,
    ENEMY_LIST
  };
};

export type { ChordDefinition, FantasyStage, FantasyGameState, FantasyGameEngineProps };
export { CHORD_DEFINITIONS, ENEMY_LIST, getCurrentEnemy };