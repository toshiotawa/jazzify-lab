設計書: ファンタジーモードへのリズムタイプ追加

本設計書は、ファンタジーモードに「リズムタイプ」を追加するためのシステム設計を詳細に記述したものである。この設計は、要件書で定義された仕様に基づき、既存のクイズタイプを維持しつつ、新たなリズムベースのゲームプレイを統合するアーキテクチャを提案する。全体の設計は、Zustandによる状態管理の統一、MP3ファイルのループ再生、判定タイミングの許容範囲などの共通要件を考慮し、拡張性とパフォーマンスを重視したものとする。コンポーネントベースの構造を採用し、フロントエンド（React/PIXI.js）とバックエンド（Supabase）の連携を明確に定義する。これにより、開発の効率化とメンテナンス性を確保し、ユーザーの没入感を高めるゲーム体験を実現する。以下では、システム全体のアーキテクチャから詳細なコンポーネント設計、データモデル、潜在的な課題と解決策までを、論理的かつ流れるような形で説明する。

システムアーキテクチャ

ファンタジーモードの全体アーキテクチャは、既存の構造を基盤としつつ、リズムタイプの追加により拡張される。フロントエンドはReactコンポーネントを基調とし、PIXI.jsを活用したビジュアルレンダリング（FantasyPIXIRenderer）とゲームロジック（FantasyGameEngine）を分離する形で構成される。状態管理にはZustandを統一的に使用し、時間管理（曲の再生タイミング、ゲージ進行）をグローバルに制御する。これにより、クイズタイプとリズムタイプの切り替えがシームレスに行える。バックエンドはSupabaseを活用し、ステージデータ（game_type, rhythm_patternなど）をデータベースから動的に取得。曲の再生はTone.jsを介してMP3ファイルを扱い、無限ループを実装する。データフローは、ステージ選択（FantasyStageSelect）からゲーム画面（FantasyGameScreen）への遷移を起点とし、エンジン内で入力処理と判定を行い、UIに反映される。リズムタイプ特有のタイミング判定は、Zustandのストアで管理されるグローバルタイムラインに基づき、±200msの許容範囲を計算する。このアーキテクチャにより、モード間の共通部分を共有しつつ、サブモード（ランダム/プログレッション）の差異を最小限のコードで扱える。

コンポーネント設計

システムの主要コンポーネントは、以下の階層構造で設計される。トップレベルとしてFantasyMainがルーティングを管理し、FantasyStageSelectでステージを選択する。選択後、FantasyGameScreenがゲームUIをレンダリングし、内部でFantasyGameEngine（ロジック）とFantasyPIXIRenderer（ビジュアル）を統合する。リズムタイプ追加に伴い、エンジンにタイミング判定モジュールを新設し、Zustandストアで曲の再生状態（BPM, 拍子, 小節数）を保持する。FantasyEffectsコンポーネントはエフェクト（魔法陣、ダメージテキスト）を扱い、PIXI.jsでアニメーションを実現。設定モーダル（FantasySettingsModal）は、ガイド表示や音量調整を制御し、エンジンに反映される。データ取得はSupabaseクライアント経由で非同期に行い、キャッシュを活用してパフォーマンスを最適化する。この設計により、クイズタイプの既存コンポーネントを再利用しつつ、リズムタイプの新要素（ループ再生、タイミング判定）をモジュール化して追加可能となる。各コンポーネントの責務分離により、テスト容易性が高まる。

FantasyGameEngine: ゲームロジックの中核。リズムタイプでは、Zustandから取得したグローバルタイムに基づき、判定タイミングを計算（例: 拍番号1.5の場合、BPMからミリ秒を導出）。ランダムパターンではallowed_chordsからコードをランダム選択し、プログレッションではchord_progressionをループ処理。失敗時はゲージを即座に満タンにし、onEnemyAttackコールバックをトリガー。成功時はonChordCorrectを呼び、敵HPを減少させる。無限リピート時は状態を保持し、リセットを防ぐ。
FantasyPIXIRenderer: ビジュアルレンダリング。リズムタイプでモンスターのゲージをリアルタイム更新し、同時出現数に応じて配置を動的に調整（例: 4体時はABCD列）。エフェクト（魔法名表示、ダメージ数値）はCSSアニメーションをPIXIに統合し、パフォーマンスを確保。
FantasyGameScreen: UIレイアウト。リズムタイプでは曲再生UIを追加し、ガイド表示（showGuide=true時）を鍵盤にオーバーレイ。判定結果を即時反映し、失敗時の敵攻撃アニメーションをトリガー。
FantasyStageSelect: ステージ選択画面。データベースからgame_typeを取得し、リズムタイプのステージを区別表示。rhythm_patternに基づくUIヒントを追加。
データモデル

データモデルは、Supabaseの既存テーブルを拡張する形で設計される。fantasy_stagesテーブルにgame_type (varchar: "quiz" | "rhythm")とrhythm_pattern (varchar: "random" | "progression")を追加。リズム関連としてbpm (int4)、time_signature (int4: 3 or 4)、loop_measures (int4)、chord_progression_data (jsonb: コード進行のJSON配列、タイミング情報含む)を定義。これにより、ステージごとのモード割り当てが可能となる。ゲーム状態はZustandストアで管理し、FantasyGameStateインターフェースで型付け（playerHp, enemyGauge, activeMonsters配列など）。コード定義（ChordDefinition）はnotes (number[]: MIDIノート)、noteNames (string[]: 音名)を保持し、displayOptsで言語/簡易化を動的に適用。無限リピート時はchord_progression_dataのオフセットをストアで保持し、ループ時の状態継続を実現する。

データフローとタイミング管理

データフローは、ステージ選択からエンジン初期化へ移行し、Zustandで時間軸を統一管理する。曲再生時はTone.jsでMP3をループ（loop_measuresに基づき2小節目にジャンプ）。タイミング判定は、グローバルタイムから小節/拍を計算し、±200msの範囲で入力を検証。成功時は敵HP減少とコールバック、失敗時はゲージ満タンと敵攻撃を即時実行。プログレッションの補充は、配列ベースのキュー管理で実現（例: ミス時の列スキップ）。懸念の無限リピート時は、ストアのオフセットで状態を保持し、ゲージの継続性を確保する。

潜在的な課題と解決策

潜在的な課題として、無限リピート時のゲージ同期が挙げられるが、Zustandのグローバルタイムで解決。同時出現数が多い場合のパフォーマンス低下は、PIXI.jsのバッチレンダリングで最適化。データベース変更はマイグレーションスクリプトで安全に適用し、既存データへの影響を最小限とする。この設計により、要件を満たしつつ、将来の拡張性を確保する。