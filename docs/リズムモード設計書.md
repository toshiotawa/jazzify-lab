# リズムモード設計書

## 1. システムアーキテクチャ

### 1.1 全体構成
```
┌─────────────────────────────────────────────────────┐
│                   React アプリケーション                │
├─────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐ │
│  │ RhythmMode  │  │  PianoMode  │  │ GuitarMode  │ │
│  │ Component   │  │  Component  │  │  Component  │ │
│  └──────┬──────┘  └─────────────┘  └─────────────┘ │
│         │                                             │
│  ┌──────┴──────────────────────────────────────────┐ │
│  │           Zustand Store (gameStore)             │ │
│  └──────┬──────────────────────────────────────────┘ │
│         │                                             │
│  ┌──────┴──────┐  ┌─────────────┐  ┌─────────────┐ │
│  │RhythmEngine │  │ GameEngine  │  │AudioEngine  │ │
│  └─────────────┘  └─────────────┘  └─────────────┘ │
└─────────────────────────────────────────────────────┘
```

### 1.2 コンポーネント構成

#### 1.2.1 UIコンポーネント
```
RhythmModeScreen
├── RhythmNotation      // リズム譜表示
├── RhythmGameArea      // ゲームエリア
│   ├── NotesLane       // ノーツレーン（PIXI.js）
│   └── DrumPads        // ドラムパッド
├── RhythmControlBar    // コントロールバー
└── RhythmSettings      // リズムモード設定
```

#### 1.2.2 ロジックコンポーネント
```
RhythmEngine
├── RhythmNoteManager   // リズムノーツ管理
├── RhythmJudgment      // 判定システム
├── RhythmAudioPlayer   // オーディオ再生
└── RhythmPatternLoader // パターン読み込み
```

## 2. データモデル設計

### 2.1 型定義

```typescript
// リズムノート
interface RhythmNote {
  id: string;
  time: number;         // 出現時刻（秒）
  padIndex: number;     // パッドインデックス (0-3)
  duration?: number;    // 持続時間（ロングノート用）
  velocity: number;     // 強さ (0-127)
  accent: boolean;      // アクセント
  ghost: boolean;       // ゴーストノート
}

// ドラムパッド設定
interface DrumPad {
  index: number;        // 0-3
  key: string;          // キーボードキー
  midiNote: number;     // MIDI ノート番号
  instrument: DrumInstrument;
  color: string;        // 表示色
  position: { x: number; y: number };
}

// ドラム楽器
type DrumInstrument = 
  | 'kick'
  | 'snare'
  | 'hihat-closed'
  | 'hihat-open'
  | 'crash'
  | 'ride'
  | 'tom-high'
  | 'tom-low';

// リズムパターン
interface RhythmPattern {
  id: string;
  name: string;
  category: RhythmCategory;
  bpm: number;
  timeSignature: TimeSignature;
  difficulty: 1 | 2 | 3 | 4 | 5;
  notes: RhythmNote[];
  duration: number;     // パターンの長さ（秒）
  description?: string;
  audioFile?: string;   // お手本音源
}

// リズムカテゴリ
type RhythmCategory = 
  | 'basic'      // 基本
  | 'jazz'       // ジャズ
  | 'latin'      // ラテン
  | 'funk'       // ファンク
  | 'rock'       // ロック
  | 'custom';    // カスタム

// 拍子記号
interface TimeSignature {
  numerator: number;    // 分子
  denominator: number;  // 分母
}

// リズムゲーム状態
interface RhythmGameState {
  pattern: RhythmPattern | null;
  activeNotes: Map<string, ActiveRhythmNote>;
  score: RhythmScore;
  settings: RhythmSettings;
  isMetronomeOn: boolean;
  currentBeat: number;
  currentMeasure: number;
}

// アクティブなリズムノート
interface ActiveRhythmNote extends RhythmNote {
  state: 'approaching' | 'active' | 'hit' | 'missed';
  y: number;            // 現在のY座標
  hitTime?: number;     // ヒット時刻
  judgment?: RhythmJudgment;
}

// リズム判定
type RhythmJudgment = 'perfect' | 'good' | 'ok' | 'miss';

// リズムスコア
interface RhythmScore {
  perfect: number;
  good: number;
  ok: number;
  miss: number;
  combo: number;
  maxCombo: number;
  accuracy: number;
  score: number;
}

// リズム設定
interface RhythmSettings {
  notesSpeed: number;           // ノーツ速度
  soundVolume: number;          // ドラム音量
  metronomeVolume: number;      // メトロノーム音量
  visualMetronome: boolean;     // 視覚的メトロノーム
  autoPlay: boolean;            // オートプレイ
  padLayout: 'linear' | 'square'; // パッドレイアウト
  judgmentStrictness: 'easy' | 'normal' | 'strict';
}
```

### 2.2 Zustand Store 拡張

```typescript
interface GameStore {
  // 既存のプロパティ...
  
  // リズムモード追加
  instrumentMode: 'piano' | 'guitar' | 'rhythm';
  rhythmState: RhythmGameState;
  
  // リズムモードアクション
  loadRhythmPattern: (pattern: RhythmPattern) => void;
  handleRhythmInput: (padIndex: number) => void;
  updateRhythmSettings: (settings: Partial<RhythmSettings>) => void;
  resetRhythmScore: () => void;
}
```

## 3. 実装詳細設計

### 3.1 RhythmEngine クラス

```typescript
class RhythmEngine {
  private pattern: RhythmPattern | null = null;
  private activeNotes: Map<string, ActiveRhythmNote> = new Map();
  private audioContext: AudioContext;
  private drumSamples: Map<DrumInstrument, AudioBuffer>;
  private currentTime: number = 0;
  private isPlaying: boolean = false;
  
  constructor(audioContext: AudioContext) {
    this.audioContext = audioContext;
    this.drumSamples = new Map();
    this.loadDrumSamples();
  }
  
  // パターン読み込み
  loadPattern(pattern: RhythmPattern): void {
    this.pattern = pattern;
    this.prepareNotes();
  }
  
  // フレーム更新
  update(deltaTime: number): void {
    if (!this.isPlaying) return;
    
    this.currentTime += deltaTime;
    this.updateActiveNotes();
    this.checkMissedNotes();
  }
  
  // 入力処理
  handleInput(padIndex: number): RhythmJudgment | null {
    const hitNote = this.findHitNote(padIndex);
    if (!hitNote) return null;
    
    const judgment = this.judge(hitNote);
    this.playDrumSound(padIndex, judgment);
    return judgment;
  }
  
  // ドラム音再生
  private playDrumSound(padIndex: number, judgment: RhythmJudgment): void {
    const pad = this.getPadConfig(padIndex);
    const buffer = this.drumSamples.get(pad.instrument);
    if (!buffer) return;
    
    const source = this.audioContext.createBufferSource();
    source.buffer = buffer;
    
    // 判定に応じて音量調整
    const gainNode = this.audioContext.createGain();
    gainNode.gain.value = this.getVolumeByJudgment(judgment);
    
    source.connect(gainNode);
    gainNode.connect(this.audioContext.destination);
    source.start();
  }
}
```

### 3.2 判定システム

```typescript
class RhythmJudgmentSystem {
  private timingWindows = {
    perfect: 30,   // ±30ms
    good: 100,     // ±100ms
    ok: 200,       // ±200ms
  };
  
  judge(note: ActiveRhythmNote, inputTime: number): RhythmJudgment {
    const timingError = Math.abs(inputTime - note.time);
    
    if (timingError <= this.timingWindows.perfect) {
      return 'perfect';
    } else if (timingError <= this.timingWindows.good) {
      return 'good';
    } else if (timingError <= this.timingWindows.ok) {
      return 'ok';
    } else {
      return 'miss';
    }
  }
  
  // 難易度に応じて判定窓を調整
  setDifficulty(strictness: 'easy' | 'normal' | 'strict'): void {
    switch (strictness) {
      case 'easy':
        this.timingWindows = { perfect: 50, good: 150, ok: 300 };
        break;
      case 'normal':
        this.timingWindows = { perfect: 30, good: 100, ok: 200 };
        break;
      case 'strict':
        this.timingWindows = { perfect: 20, good: 60, ok: 120 };
        break;
    }
  }
}
```

### 3.3 PIXI.js 統合

```typescript
class RhythmNotesRenderer {
  private app: PIXI.Application;
  private notesContainer: PIXI.Container;
  private padsContainer: PIXI.Container;
  private effectsContainer: PIXI.Container;
  
  constructor(canvas: HTMLCanvasElement) {
    this.app = new PIXI.Application({
      view: canvas,
      width: 800,
      height: 600,
      antialias: true,
      backgroundColor: 0x1a1a1a,
    });
    
    this.setupContainers();
  }
  
  // ノーツ描画
  renderNote(note: ActiveRhythmNote): void {
    const noteSprite = new PIXI.Graphics();
    const padConfig = this.getPadConfig(note.padIndex);
    
    // ノーツの形状描画
    noteSprite.beginFill(padConfig.color);
    noteSprite.drawRoundedRect(0, 0, 80, 30, 10);
    noteSprite.endFill();
    
    // 位置設定
    noteSprite.x = this.getPadX(note.padIndex);
    noteSprite.y = note.y;
    
    this.notesContainer.addChild(noteSprite);
  }
  
  // ヒットエフェクト
  showHitEffect(padIndex: number, judgment: RhythmJudgment): void {
    const effect = new PIXI.Graphics();
    const color = this.getJudgmentColor(judgment);
    
    // エフェクト描画
    effect.beginFill(color, 0.5);
    effect.drawCircle(0, 0, 50);
    effect.endFill();
    
    effect.x = this.getPadX(padIndex) + 40;
    effect.y = this.judgmentLineY;
    
    // アニメーション
    gsap.to(effect, {
      alpha: 0,
      width: 100,
      height: 100,
      duration: 0.3,
      onComplete: () => {
        this.effectsContainer.removeChild(effect);
      }
    });
    
    this.effectsContainer.addChild(effect);
  }
}
```

## 4. 音源管理

### 4.1 ドラムサンプル構成

```
/public/sounds/drums/
├── kick.wav
├── snare.wav
├── hihat-closed.wav
├── hihat-open.wav
├── crash.wav
├── ride.wav
├── tom-high.wav
└── tom-low.wav
```

### 4.2 音源ローダー

```typescript
class DrumSampleLoader {
  private audioContext: AudioContext;
  private samples: Map<DrumInstrument, AudioBuffer> = new Map();
  
  async loadAll(): Promise<void> {
    const instruments: DrumInstrument[] = [
      'kick', 'snare', 'hihat-closed', 'hihat-open',
      'crash', 'ride', 'tom-high', 'tom-low'
    ];
    
    const loadPromises = instruments.map(async (instrument) => {
      const url = `/sounds/drums/${instrument}.wav`;
      const buffer = await this.loadSample(url);
      this.samples.set(instrument, buffer);
    });
    
    await Promise.all(loadPromises);
  }
  
  private async loadSample(url: string): Promise<AudioBuffer> {
    const response = await fetch(url);
    const arrayBuffer = await response.arrayBuffer();
    return this.audioContext.decodeAudioData(arrayBuffer);
  }
}
```

## 5. リズムパターンデータ

### 5.1 基本パターン

```typescript
const basicPatterns: RhythmPattern[] = [
  {
    id: 'basic-4beat',
    name: '4ビート',
    category: 'basic',
    bpm: 120,
    timeSignature: { numerator: 4, denominator: 4 },
    difficulty: 1,
    duration: 4,
    notes: [
      { id: '1', time: 0.0, padIndex: 0, velocity: 100, accent: true, ghost: false },
      { id: '2', time: 0.5, padIndex: 2, velocity: 80, accent: false, ghost: false },
      { id: '3', time: 1.0, padIndex: 1, velocity: 90, accent: false, ghost: false },
      { id: '4', time: 1.5, padIndex: 2, velocity: 80, accent: false, ghost: false },
      // ... 繰り返し
    ]
  },
  // ... 他のパターン
];
```

### 5.2 パターンジェネレーター

```typescript
class RhythmPatternGenerator {
  // メトロノームパターン生成
  generateMetronome(bpm: number, duration: number): RhythmPattern {
    const beatInterval = 60 / bpm;
    const notes: RhythmNote[] = [];
    
    for (let time = 0; time < duration; time += beatInterval) {
      notes.push({
        id: `metro-${time}`,
        time,
        padIndex: 2, // ハイハット
        velocity: time % 1 === 0 ? 100 : 70, // 強拍を強調
        accent: time % 1 === 0,
        ghost: false
      });
    }
    
    return {
      id: 'metronome',
      name: 'メトロノーム',
      category: 'basic',
      bpm,
      timeSignature: { numerator: 4, denominator: 4 },
      difficulty: 1,
      duration,
      notes
    };
  }
}
```

## 6. インタラクション設計

### 6.1 キーボード入力

```typescript
const keyboardMapping = {
  'KeyD': 0,  // Kick
  'KeyF': 1,  // Snare
  'KeyJ': 2,  // Hi-hat
  'KeyK': 3,  // Crash/Ride
};
```

### 6.2 MIDI入力マッピング

```typescript
const midiMapping = {
  36: 0,  // C1 - Kick
  38: 1,  // D1 - Snare
  42: 2,  // F#1 - Closed Hi-hat
  49: 3,  // C#2 - Crash
};
```

### 6.3 タッチ入力

```typescript
class TouchInputHandler {
  private padElements: HTMLElement[];
  
  setupTouchListeners(): void {
    this.padElements.forEach((pad, index) => {
      pad.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.handlePadTouch(index);
      });
    });
  }
  
  private handlePadTouch(padIndex: number): void {
    // ビジュアルフィードバック
    this.showTouchFeedback(padIndex);
    
    // 入力イベント発火
    this.emitInputEvent(padIndex);
  }
}
```

## 7. パフォーマンス最適化

### 7.1 オブジェクトプール

```typescript
class RhythmNotePool {
  private pool: ActiveRhythmNote[] = [];
  private activeNotes: Set<ActiveRhythmNote> = new Set();
  
  acquire(): ActiveRhythmNote {
    if (this.pool.length > 0) {
      const note = this.pool.pop()!;
      this.activeNotes.add(note);
      return note;
    }
    
    const newNote = this.createNote();
    this.activeNotes.add(newNote);
    return newNote;
  }
  
  release(note: ActiveRhythmNote): void {
    this.activeNotes.delete(note);
    this.resetNote(note);
    this.pool.push(note);
  }
}
```

### 7.2 描画最適化

- ノーツのバッチレンダリング
- 画面外ノーツの非描画
- テクスチャアトラス使用
- WebGLレンダラー活用

## 8. エラーハンドリング

### 8.1 音源読み込みエラー

```typescript
class AudioErrorHandler {
  handleLoadError(instrument: DrumInstrument, error: Error): void {
    console.error(`Failed to load ${instrument}:`, error);
    
    // フォールバック音源を使用
    this.useFallbackSound(instrument);
    
    // ユーザーに通知
    this.notifyUser(`一部の音源の読み込みに失敗しました`);
  }
}
```

### 8.2 タイミング同期エラー

```typescript
class TimingSyncHandler {
  private maxLatency = 50; // 50ms
  
  checkSync(audioTime: number, visualTime: number): void {
    const diff = Math.abs(audioTime - visualTime);
    
    if (diff > this.maxLatency) {
      console.warn(`Timing sync issue detected: ${diff}ms`);
      this.recalibrate();
    }
  }
}
```

## 9. テスト戦略

### 9.1 単体テスト

- 判定システムのテスト
- パターン生成のテスト
- 入力処理のテスト

### 9.2 統合テスト

- 音源再生タイミングテスト
- レイテンシ測定テスト
- マルチプラットフォームテスト

### 9.3 パフォーマンステスト

- 60FPS維持テスト
- メモリリークテスト
- 低スペック端末テスト