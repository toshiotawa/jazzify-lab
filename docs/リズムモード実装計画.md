# リズムモード実装計画

## 1. 実装フェーズ

### Phase 1: 基盤整備（2日間）
- [ ] TypeScript型定義の追加
- [ ] Zustandストアの拡張
- [ ] 基本的なUI構造の作成
- [ ] ルーティング設定

### Phase 2: コア機能実装（3日間）
- [ ] RhythmEngineクラスの実装
- [ ] 判定システムの実装
- [ ] ドラム音源の準備と読み込み
- [ ] 基本的な入力処理

### Phase 3: UI実装（3日間）
- [ ] ドラムパッドコンポーネント
- [ ] ノーツ降下表示（PIXI.js）
- [ ] スコア表示
- [ ] 設定画面

### Phase 4: 統合とテスト（2日間）
- [ ] 既存システムとの統合
- [ ] パフォーマンス最適化
- [ ] バグ修正
- [ ] ユーザーテスト

## 2. 詳細実装手順

### 2.1 Phase 1: 基盤整備

#### Step 1: TypeScript型定義
```typescript
// src/types/rhythm.ts
export interface RhythmNote {
  id: string;
  time: number;
  padIndex: number;
  velocity: number;
  accent: boolean;
  ghost: boolean;
}

export interface RhythmPattern {
  id: string;
  name: string;
  category: RhythmCategory;
  bpm: number;
  timeSignature: TimeSignature;
  difficulty: 1 | 2 | 3 | 4 | 5;
  notes: RhythmNote[];
  duration: number;
}

// ... その他の型定義
```

#### Step 2: Zustandストア拡張
```typescript
// src/stores/gameStore.ts に追加
interface GameStoreState {
  // 既存のプロパティ...
  
  // リズムモード状態
  rhythmState: {
    pattern: RhythmPattern | null;
    activeNotes: Map<string, ActiveRhythmNote>;
    score: RhythmScore;
    settings: RhythmSettings;
  };
  
  // リズムモードアクション
  loadRhythmPattern: (pattern: RhythmPattern) => void;
  handleRhythmInput: (padIndex: number) => void;
  updateRhythmSettings: (settings: Partial<RhythmSettings>) => void;
}
```

#### Step 3: ルーティング設定
```typescript
// src/App.tsx
const App = () => {
  const instrumentMode = useGameStore(state => state.settings.instrumentMode);
  
  return (
    <div className="app">
      {instrumentMode === 'piano' && <PianoMode />}
      {instrumentMode === 'guitar' && <GuitarMode />}
      {instrumentMode === 'rhythm' && <RhythmMode />}
    </div>
  );
};
```

### 2.2 Phase 2: コア機能実装

#### Step 1: RhythmEngine実装
```typescript
// src/utils/rhythmEngine.ts
export class RhythmEngine {
  private pattern: RhythmPattern | null = null;
  private activeNotes: Map<string, ActiveRhythmNote>;
  private audioContext: AudioContext;
  private drumSamples: Map<DrumInstrument, AudioBuffer>;
  
  constructor() {
    this.activeNotes = new Map();
    this.audioContext = new AudioContext();
    this.drumSamples = new Map();
    this.initialize();
  }
  
  async initialize() {
    await this.loadDrumSamples();
  }
  
  // ... その他のメソッド
}
```

#### Step 2: ドラム音源準備
```bash
# public/sounds/drums/ ディレクトリに以下のファイルを配置
- kick.wav
- snare.wav
- hihat-closed.wav
- hihat-open.wav
- crash.wav
- ride.wav
- tom-high.wav
- tom-low.wav
```

#### Step 3: 判定システム実装
```typescript
// src/utils/rhythmJudgment.ts
export class RhythmJudgmentSystem {
  judge(note: ActiveRhythmNote, inputTime: number): RhythmJudgment {
    const error = Math.abs(inputTime - note.time);
    
    if (error <= 30) return 'perfect';
    if (error <= 100) return 'good';
    if (error <= 200) return 'ok';
    return 'miss';
  }
}
```

### 2.3 Phase 3: UI実装

#### Step 1: メインコンポーネント
```typescript
// src/components/rhythm/RhythmModeScreen.tsx
export const RhythmModeScreen: React.FC = () => {
  return (
    <div className="rhythm-mode-screen">
      <RhythmNotation />
      <RhythmGameArea />
      <RhythmControlBar />
    </div>
  );
};
```

#### Step 2: ドラムパッド実装
```typescript
// src/components/rhythm/DrumPads.tsx
export const DrumPads: React.FC = () => {
  const handlePadClick = (padIndex: number) => {
    // 入力処理
  };
  
  return (
    <div className="drum-pads">
      {[0, 1, 2, 3].map(index => (
        <DrumPad
          key={index}
          index={index}
          onClick={() => handlePadClick(index)}
        />
      ))}
    </div>
  );
};
```

#### Step 3: PIXI.js統合
```typescript
// src/components/rhythm/RhythmNotesRenderer.tsx
export const RhythmNotesRenderer: React.FC = () => {
  const canvasRef = useRef<HTMLCanvasElement>(null);
  
  useEffect(() => {
    if (!canvasRef.current) return;
    
    const renderer = new RhythmNotesRendererClass(canvasRef.current);
    renderer.start();
    
    return () => renderer.destroy();
  }, []);
  
  return <canvas ref={canvasRef} />;
};
```

### 2.4 Phase 4: 統合とテスト

#### Step 1: 既存システムとの統合
- GameEngineとの連携
- 音源管理システムの共有
- 設定システムの統合

#### Step 2: パフォーマンス最適化
- オブジェクトプーリング実装
- 描画最適化
- メモリ管理改善

#### Step 3: テスト実装
```typescript
// src/__tests__/rhythm/rhythmEngine.test.ts
describe('RhythmEngine', () => {
  test('should judge perfect timing correctly', () => {
    // テストコード
  });
});
```

## 3. ファイル構成

```
src/
├── components/
│   └── rhythm/
│       ├── RhythmModeScreen.tsx
│       ├── DrumPads.tsx
│       ├── RhythmNotation.tsx
│       ├── RhythmGameArea.tsx
│       ├── RhythmControlBar.tsx
│       └── RhythmNotesRenderer.tsx
├── utils/
│   ├── rhythmEngine.ts
│   ├── rhythmJudgment.ts
│   ├── rhythmPatternLoader.ts
│   └── drumSampleLoader.ts
├── types/
│   └── rhythm.ts
├── data/
│   └── rhythmPatterns/
│       ├── basic.ts
│       ├── jazz.ts
│       └── latin.ts
└── stores/
    └── gameStore.ts (拡張)
```

## 4. 実装優先順位

### 高優先度
1. 基本的な入力と音再生
2. シンプルな判定システム
3. 最小限のUI（ドラムパッド）
4. 基本的なリズムパターン

### 中優先度
1. PIXI.jsによるノーツ表示
2. スコアリングシステム
3. 設定画面
4. 複数のリズムパターン

### 低優先度
1. 高度なエフェクト
2. カスタムパターン作成
3. オンラインランキング
4. 詳細な統計情報

## 5. リスクと対策

### リスク1: 音源再生のレイテンシ
**対策**: Web Audio APIの適切な使用、バッファリング最適化

### リスク2: 異なるデバイスでの入力遅延
**対策**: キャリブレーション機能の実装、デバイス別の調整値保存

### リスク3: パフォーマンス問題
**対策**: オブジェクトプーリング、描画最適化、不要な再レンダリング防止

## 6. 成功基準

### 機能面
- [ ] 4つのドラムパッドで基本的なリズムが演奏可能
- [ ] タイミング判定が正確に動作
- [ ] スコアが正しく計算される
- [ ] 複数のリズムパターンが選択可能

### パフォーマンス面
- [ ] 60FPSを維持
- [ ] 入力レイテンシ10ms以下
- [ ] メモリリークなし
- [ ] スムーズな音源再生

### ユーザビリティ面
- [ ] 直感的な操作
- [ ] レスポンシブデザイン対応
- [ ] 適切なフィードバック
- [ ] 設定のカスタマイズ可能

## 7. デプロイメント計画

### ステージ1: 内部テスト
- 開発環境でのテスト
- 基本機能の動作確認
- バグ修正

### ステージ2: ベータテスト
- 限定ユーザーへの公開
- フィードバック収集
- パフォーマンス調整

### ステージ3: 本番リリース
- 全ユーザーへの公開
- モニタリング体制構築
- 継続的な改善

## 8. 今後の拡張計画

### バージョン1.1
- より多くのリズムパターン追加
- 詳細な練習モード
- 成績グラフ表示

### バージョン1.2
- カスタムパターン作成機能
- パターンの共有機能
- マルチプレイヤー対応

### バージョン2.0
- AI によるリズム生成
- リアルタイムコラボレーション
- プロフェッショナル向け機能