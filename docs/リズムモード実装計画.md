実装計画: ファンタジーモードへのリズムタイプ追加

本実装計画は、要件書と設計書に基づき、ファンタジーモードに「リズムタイプ」を追加するための具体的なステップを定義したものである。この計画では、開発の流れを論理的に整理し、既存コードの最小限の変更を重視しつつ、新機能の統合を効率的に進める。Zustandによる時間管理の統一、MP3ファイルのループ再生、判定タイミングの許容範囲などの共通要件を遵守し、クイズタイプとの互換性を維持する。実装は、データベースマイグレーションから始まり、バックエンド連携、エンジン拡張、UI更新、テストの順で進める。潜在的な課題（例: 無限リピート時のゲージ同期）を事前に考慮し、解決策を組み込む。全体の開発期間は2-3週間を想定し、段階的なコミットで進捗管理を行う。提供されたFantasySoundManager.tsを活用し、サウンド関連の拡張を強化する。以下では、各フェーズの詳細、タスク分解、依存関係、潜在リスクを包括的に説明する。

全体実装戦略

実装はモジュールベースで進め、FantasyGameEngineを中核として拡張する。リズムタイプのサブモード（ランダム/プログレッション）はエンジン内で分岐し、Zustandストアでグローバル時間を管理（BPM、拍子、小節数を保持）。曲再生はTone.jsを活用し、ループ時に状態を継続。UIはFantasyGameScreenを更新し、PIXI.jsでタイミング視覚化を追加。データベースはSupabaseのマイグレーションで拡張し、ステージごとのモード割り当てを動的に行う。FantasySoundManager.tsを統合し、リズム入力時の効果音を同期。テストはユニット（判定ロジック）とE2E（ゲームフロー）でカバーし、パフォーマンス監視を組み込む。この戦略により、既存のクイズタイプを破壊せず、リズムタイプをシームレスに追加可能となる。

フェーズ1: データベースとバックエンドの準備

データモデルを拡張し、リズムタイプのデータを扱えるようにする。このフェーズは開発の基盤となり、1-2日で完了させる。

マイグレーションの実行: supabase/migrationsに新しいSQLスクリプトを作成（例: 20250730000002_add_rhythm_fields.sql）。fantasy_stagesテーブルに以下のカラムを追加:

game_type (varchar, DEFAULT 'quiz'): "quiz"または"rhythm"でモードを指定。
rhythm_pattern (varchar, NULLABLE): "random"または"progression"（リズムタイプ時のみ使用）。
bpm (int4, NULLABLE): テンポ（例: 120）。
time_signature (int4, NULLABLE): 拍子（3または4）。
loop_measures (int4, NULLABLE): ループ開始小節（例: 8）。
chord_progression_data (jsonb, NULLABLE): コード進行とタイミングのJSON（例: [{"chord": "C", "measure": 1, "beat": 1.5}]）。
mp3_url (varchar, NULLABLE): MP3ファイルパス（例: "/demo-1.mp3"）。
rhythm_data (text, NULLABLE): リズムデータのファイルパス（JSON読み込み用）。 既存データへの影響を避けるため、NULLABLEとし、DEFAULT値を設定。スクリプトでRLSポリシーを更新し、管理者権限を確保。
Supabase関数/クライアントの更新: supabaseFantasyStages.tsにリズム関連のクエリを追加（例: fetchFantasyStageByIdで新カラムを取得）。Zustandストア（gameStore.ts）を拡張し、リズム状態（currentTime, bpm, timeSignatureなど）を追加。FantasySoundManager.tsをインポートし、init()をアプリ起動時に呼び出し、効果音をプリロード。

依存関係とリスク: Supabaseのダウンタイムを避けるため、ローカルマイグレーションでテスト。潜在リスクとしてJSONパースエラーを考慮し、try-catchでハンドリング。

フェーズ2: ゲームエンジンの拡張

FantasyGameEngine.tsxをリズムタイプ対応に拡張。このフェーズはコアロジックのため、3-5日を割り当てる。

Zustandストアの時間管理統一: gameStore.tsにリズム状態を追加（currentTime: number, isPlaying: boolean, loopStart: number）。Tone.jsをインポートし、MP3再生を管理（start()でループ設定）。無限リピート時はcurrentTimeを継続的に更新し、ゲージをリセットせず保持（懸念解決）。

エンジンロジックの分岐: FantasyGameEngineでgame_typeに基づき分岐（if (stage.game_type === 'rhythm')）。リズムタイプ時は、JSONからタイミングデータを読み込み（chord_progression_data）、currentTimeと±200msで判定。成功時はonChordCorrectを呼び、失敗時はゲージを即満タンに（handleEnemyAttack）。ランダムパターンは1小節に1コードをランダム選択（allowed_chordsから）、プログレッションは配列ループ（補充ロジック: テーブル形式で列管理、ミス時は連続番号割り当て）。同時出現数はsimultaneousMonsterCountで制御（1体: ランダム、4体: プログレッション）。

サウンド統合: FantasySoundManager.tsをエンジンにインポート。成功/失敗時にplayMyAttack()やplayEnemyAttack()を呼び、リズム入力と同期。ルート音再生（playRootNote()）を正解時にオプションで追加。

依存関係とリスク: Tone.jsのAutoplay制限を考慮し、ユーザーインタラクション後にinit()。タイミングずれのリスクは、requestAnimationFrameでcurrentTimeを同期。

フェーズ3: UI/ビジュアルコンポーネントの更新

FantasyGameScreen.tsxとFantasyPIXIRenderer.tsxをリズム対応に。2-4日で実装。

ゲーム画面の拡張: FantasyGameScreenでgame_type="rhythm"時、曲再生UIとタイミングインジケーターを追加（PIXIで拍子視覚化）。ガイド表示（showGuide=true時）は鍵盤に音名を表示。FantasyPIXIRendererでゲージをリアルタイム更新（マルチモンスター対応）。

エフェクト拡張: FantasyEffects.tsxでリズム成功時のエフェクトを追加（triggerMagicCircleなど）。FantasySoundManager.tsをインポートし、入力タイミングでSEを同期。

設定モーダルの調整: FantasySettingsModalでリズム関連設定（BPM調整など）を追加、Zustandに反映。

依存関係とリスク: PIXIのパフォーマンス低下を避けるため、バッチレンダリングを活用。モバイル対応でスクロールを最適化。

フェーズ4: テストとデバッグ

実装後、1-2日でテストを実施。

ユニットテスト: Jestで判定ロジック（±200ms）、ループ処理、ゲージ同期をテスト。
E2Eテスト: Cypressでゲームフロー（成功/失敗、クリア/オーバー）を検証。
パフォーマンスタイミング: ループ時の遅延を計測し、調整。
クロスブラウザテスト: Chrome/Safariで音声/タイミングを確認。
潜在的な課題と解決策

課題1: 無限リピート時のゲージ機能: ZustandでcurrentTimeを継続管理し、ループ時にオフセットを調整。
課題2: 同時出現数のUI崩れ: PIXIで動的スケーリングを実装。
課題3: サウンド遅延: FantasySoundManager.tsのcloneNode()で同時再生を確保。
リスク管理: 段階コミットで進捗確認、コードレビューを実施。
この計画により、要件を満たした高品質な実装を実現する。次は具体的なdiff生成へ進む。